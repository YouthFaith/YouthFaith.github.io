<!DOCTYPE html>





<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">
  <meta name="google-site-verification" content="Mfi9qKlk-eXPFCoKeaSQS9tInGifF_4VftSzH9ucoss">
  <meta name="baidu-site-verification" content="LcRNZHLxU2">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: true,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: './public/search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    }
  };
</script>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #00CDCD;
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #00CDCD, 0 0 5px #00CDCD; 
    }
    .pace .pace-activity {
        border-top-color: #00CDCD;    
        border-left-color: #00CDCD;    
    }
</style>

  <meta name="description" content="All roads lead to Rome.  ThreadConcept of Thread A thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler. Multiple threads can exist">
<meta name="keywords" content="Ultimate Knowledge,OS System,C Language">
<meta property="og:type" content="article">
<meta property="og:title" content="Thread Management">
<meta property="og:url" content="http://youthfaith.cn/2019/04/07/ThreadManagement/index.html">
<meta property="og:site_name" content="YouthFaith&#39;s Blog">
<meta property="og:description" content="All roads lead to Rome.  ThreadConcept of Thread A thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler. Multiple threads can exist">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-10-08T14:20:59.053Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Thread Management">
<meta name="twitter:description" content="All roads lead to Rome.  ThreadConcept of Thread A thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler. Multiple threads can exist">
  <link rel="canonical" href="http://youthfaith.cn/2019/04/07/ThreadManagement/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Thread Management | YouthFaith's Blog</title>
  <meta name="generator" content="Hexo 3.9.0">
  








  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  <div class="container use-motion">
    <div class="headband"></div>
<a href="https://github.com/YouthFaith" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YouthFaith's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Welcome to My World!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Search</a>
      </li>
    
  </ul>

    

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-wrapper">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://youthfaith.cn/2019/04/07/ThreadManagement/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YiHe Huang">
      <meta itemprop="description" content="YouthFaith's Blog">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YouthFaith's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Thread Management

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2019-04-07 12:07:06" itemprop="dateCreated datePublished" datetime="2019-04-07T12:07:06+08:00">2019-04-07</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-08 22:20:59" itemprop="dateModified" datetime="2019-10-08T22:20:59+08:00">2019-10-08</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Programming/" itemprop="url" rel="index"><span itemprop="name">Programming</span></a></span>

                
                
              
            </span>
          

          
            <span class="post-meta-item" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          
          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">Symbols count in article: </span>
              
              <span>41k</span>
            </span>
          
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">Reading time &asymp;</span>
              
              <span>37 mins.</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote class="blockquote-center"><p>All roads lead to Rome.</p>
</blockquote>
<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><h3 id="Concept-of-Thread"><a href="#Concept-of-Thread" class="headerlink" title="Concept of Thread"></a>Concept of Thread</h3><ol>
<li>A thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler. Multiple threads can exist within one process, executing concurrently and sharing resources such as memory, while different processes do not share these resources. In particular, the threads of a process share its executable code and the values of its dynamically allocated variables and non-thread-local global variables at any given time. In a word, the process is the basic unit of resource allocation and the thread is the basic unit of independent scheduling. <a id="more"></a></li>
<li>The implementation of threads can be divided into two types: user-level thread and kernel-level thread. In particular, the user-level threads are implemented by users to solve the context switch problem and the kernel is not aware of the existence of these threads. It handles them as if they were single-threaded processes. User-level threads are small and much faster than kernel level threads. They are represented by a program counter (<strong>PC</strong>), stack, registers and a small process control block. Also, there is no kernel involvement in synchronization for user-level threads. Kernel-level threads are handled by the operating system directly and the thread management is done by the kernel. The context information for the process as well as the process threads is all managed by the kernel. Because of this, kernel-level threads are slower than user-level threads.</li>
<li>Each thread within a process has its own unique identity, which is valid only in the process environment which it belongs to, and whose data type is <strong>pthread_t</strong>. The link library file needs to be used at compile time by <strong>-lpthread</strong> option.</li>
</ol>
<h3 id="Thread-vs-Process"><a href="#Thread-vs-Process" class="headerlink" title="Thread vs. Process"></a>Thread vs. Process</h3><ol>
<li><p>Threads differ from traditional multitasking operating system processes in several ways described below.</p>
<ul>
<li>Processes are typically independent, while threads exist as subsets of a process.</li>
<li>Processes carry considerably more state information than threads, whereas multiple threads within a process share process state as well as memory and other resources.</li>
<li>Processes have separate address spaces, whereas threads share their address space.</li>
<li>Processes interact only through system-provided inter-process communication mechanisms.</li>
<li>Context switching between threads in the same process is typically faster than context switching between processes.</li>
</ul>
</li>
<li>In a word, threads are used for small tasks, whereas processes are used for more ‘heavyweight’ tasks – basically the execution of applications. Another difference between a thread and a process is that threads within the same process share the same address space, whereas different processes do not.</li>
</ol>
<h3 id="Thread-Model"><a href="#Thread-Model" class="headerlink" title="Thread Model"></a>Thread Model</h3><ol>
<li><strong>1:1</strong> kernel-level threading: threads created by the user in a 1:1 correspondence with schedulable entities in the kernel are the simplest possible threading implementation. </li>
<li><strong>N:1</strong> (user-level threading): imply that all application-level threads map to one kernel-level scheduled entity; the kernel has no knowledge of the application threads. With this approach, context switching can be done very quickly and, in addition, it can be implemented even on simple kernels which do not support threading. One of the major drawbacks, however, is that it cannot benefit from the hardware acceleration on multi-threaded processors or multi-processor computers: there is never more than one thread being scheduled at the same time. For example: If one of the threads needs to execute an <strong>I/O</strong> request, the whole process is blocked and the threading advantage cannot be used. </li>
<li><strong>M:N</strong> (hybrid threading): map some M number of application threads onto some N number of kernel entities, or “virtual processors.” This is a compromise between kernel-level (“1:1”) and user-level (“N:1”) threading. In general, “M:N” threading systems are more complex to implement than either kernel or user threads, because changes to both kernel and user-space code are required. In the M:N implementation, the threading library is responsible for scheduling user threads on the available schedulable entities; this makes context switching of threads very fast, as it avoids system calls. However, this increases complexity and the likelihood of priority inversion, as well as suboptimal scheduling without extensive (and expensive) coordination between the userland scheduler and the kernel scheduler.</li>
</ol>
<h3 id="Thread-Creation"><a href="#Thread-Creation" class="headerlink" title="Thread Creation"></a>Thread Creation</h3><ol>
<li><p>A standardized interface for thread implementation is POSIX Threads (Pthreads), which is a set of C-function library calls. OS vendors are free to implement the interface as desired, but the application developer should be able to use the same interface across multiple platforms. Most Unix platforms including Linux support Pthreads. </p>
</li>
<li><p>Some common functions to creating threads</p>
<ul>
<li><p><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</code>: start a new thread in the calling process. The <em>attr</em> argument points to a <em>pthread_attr_t</em> structure whose contents are used at thread creation time to determine attributes for the new thread. Before returning, a successful call stores the ID of the new thread in the buffer pointed to by <em>thread</em>. The new thread starts execution by invoking <u>start_routine</u>(). <em>arg</em> is passed as the sole argument of <u>start_routine</u>(). On success, it returns 0; on error, it returns an error number, and the contents of <em>*thread</em> are undefined. </p>
</li>
<li><p><code>int pthread_equal(pthread_t t1, pthread_t t2);</code>: compare two thread identifiers. If the two thread IDs are equal, it returns a nonzero value; otherwise, it returns 0.</p>
</li>
<li><p><code>pthread_t pthread_self(void);</code>: return the ID of the calling thread. This is the same value that is returned in <strong>*thread</strong> in the <u>pthread_create</u>() call that created this thread. And this function always succeeds, returning the calling thread’s ID.</p>
</li>
<li><p><code>int pthread_join(pthread_t thread, void **retval);</code>: wait for the thread specified by <em>thread</em> to terminate. If that thread has already terminated, then <u>pthread_join</u>() returns immediately. The <em>thread</em> specified by <em>thread</em> must be joinable. If <em>retval</em> is not NULL, then <u>pthread_join</u>() copies the exit status of the target thread (i.e., the value that the target thread supplied to <u>pthread_exit</u>()) into the location pointed to by <em>retval</em>. On success, it returns 0; on error, it returns an error number.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implement the race between hare and tortoise</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="keyword">long</span> start;</span><br><span class="line">    <span class="keyword">long</span> end;</span><br><span class="line">&#125; RaceArg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">th_fn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RaceArg* r = (RaceArg*)arg;</span><br><span class="line">    <span class="keyword">long</span> i = r-&gt;start;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= r-&gt;end; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s(%lx) run %ld\n"</span>, r-&gt;name, pthread_self(), i);</span><br><span class="line">        usleep(r-&gt;time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)(r-&gt;end - r-&gt;start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> rabbit, turtle;</span><br><span class="line"></span><br><span class="line">    RaceArg r_a = &#123; <span class="string">"rabbit"</span>, (<span class="keyword">int</span>)(drand48() * <span class="number">1000000</span>), <span class="number">20</span>, <span class="number">50</span> &#125;;</span><br><span class="line">    RaceArg <span class="keyword">r_t</span> = &#123; <span class="string">"turtle"</span>, (<span class="keyword">int</span>)(drand48() * <span class="number">1000000</span>), <span class="number">10</span>, <span class="number">60</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_create(&amp;rabbit, <span class="literal">NULL</span>, th_fn, (<span class="keyword">void</span>*)&amp;r_a)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread_create error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_create(&amp;turtle, <span class="literal">NULL</span>, th_fn, (<span class="keyword">void</span>*)&amp;<span class="keyword">r_t</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread_create error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span>* distance;</span><br><span class="line"></span><br><span class="line">    pthread_join(rabbit, (<span class="keyword">void</span>**)&amp;distance);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"rabbit's distance is %ld\n"</span>, (<span class="keyword">long</span>)distance);</span><br><span class="line">    pthread_join(turtle, (<span class="keyword">void</span>**)&amp;distance);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"turtle's distance is %ld\n"</span>, (<span class="keyword">long</span>)distance);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"control thread id: %lx\n"</span>, pthread_self());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"finished!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="Thread-Termination"><a href="#Thread-Termination" class="headerlink" title="Thread Termination"></a>Thread Termination</h3><ol>
<li><p>Active termination</p>
<ul>
<li>Call <strong>return</strong> statement</li>
<li>Call <code>pthread_exit()</code> function</li>
<li><code>void pthread_exit(void *retval);</code>: terminate the calling thread and returns a value via <strong>retval</strong> that (if the thread is joinable) is available to another thread in the same process that calls <code>pthread_join()</code>.</li>
</ul>
</li>
<li><p>Passive termination</p>
<ul>
<li>Other thread calls <code>pthread_cancel(pthid)</code> function to end it.</li>
<li><code>int pthread_cancel(pthread_t thread);</code>: send a cancellation request to the thread <em>thread</em>. Whether and when the target thread reacts to the cancellation request depends on two attributes that are under the control of that thread: its cancelability <em>state</em> and <em>type</em>. On success, it returns 0; on error, it returns a nonzero error number.</li>
</ul>
</li>
<li>Release of thread resources: Whether it’s active termination or passive termination, none of the threads automatically releases resources. But we can use the methods below, either call the <code>pthread_join()</code> function, or set the detach state of the thread to <strong>PTHREAD_CREATE_DETACHED</strong>.</li>
<li>Cleanup function of a thread<ul>
<li><code>void pthread_cleanup_push(void (*routine)(void *), void *arg);</code>: push <em>routine</em> onto the top of the stack of clean-up handlers. When <em>routine</em> is later invoked, it will be given <em>arg</em> as its argument.</li>
<li><code>void pthread_cleanup_pop(int execute);</code>: remove the <em>routine</em> at the top of the stack of clean-up handlers, and optionally executes it if execute is nonzero.</li>
</ul>
</li>
</ol>
<h3 id="Thread-Attribution"><a href="#Thread-Attribution" class="headerlink" title="Thread Attribution"></a>Thread Attribution</h3><ol>
<li><p>Some common attribution about thread</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Detach state        = PTHREAD_CREATE_JOINABLE/PTHREAD_CREATE_DETACHED</span><br><span class="line">Scope               = PTHREAD_SCOPE_SYSTEM</span><br><span class="line">Inherit scheduler   = PTHREAD_EXPLICIT_SCHED</span><br><span class="line">Scheduling policy   = SCHED_OTHER</span><br><span class="line">Scheduling priority = <span class="number">0</span></span><br><span class="line">Guard size          = <span class="number">0</span> bytes</span><br><span class="line">Stack address       = <span class="number">0x40197000</span></span><br><span class="line">Stack size          = <span class="number">0x3000000</span> bytes</span><br></pre></td></tr></table></figure>
</li>
<li><p>Some common function about thread attribution</p>
<ul>
<li><p><code>int pthread_attr_init(pthread_attr_t *attr);</code>: initialize the thread attributes object pointed to by <em>attr</em> with default attribute values. On success, it returns 0; on error, they return a nonzero error number.</p>
</li>
<li><p><code>int pthread_attr_destroy(pthread_attr_t *attr);</code>: used when a thread attributes object is no longer required. On success, it returns 0; on error, they return a nonzero error number.</p>
</li>
<li><p><code>int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);</code>: return the detach state attribute of the thread attributes object <em>attr</em> in the buffer pointed to by <em>detachstate</em>. On success, it returns 0; on error, they return a nonzero error number.</p>
</li>
<li><p><code>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code>: set the detach state attribute of the thread attributes object referred to by <em>attr</em> to the value specified in <em>detachstate</em>. On success, it returns 0; on error, they return a nonzero error number.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare the difference between pthread_join and modify detach state</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_state</span><span class="params">(<span class="keyword">pthread_attr_t</span>* attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">if</span> (pthread_attr_getdetachstate(attr, &amp;state) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"getdetachstate error\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state == PTHREAD_CREATE_JOINABLE) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"joinable state\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == PTHREAD_CREATE_DETACHED) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"detached state\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"error state\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">th_fn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= (<span class="keyword">long</span>)arg; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err, res;</span><br><span class="line">    <span class="keyword">pthread_t</span> default_th, detach_th;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    out_state(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_create(&amp;default_th, &amp;attr, th_fn, (<span class="keyword">void</span>*)<span class="number">100</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread create error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_join(default_th, (<span class="keyword">void</span>*)&amp;res)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, strerror(err));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"default return is %d\n"</span>, (<span class="keyword">int</span>)res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-----------------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    out_state(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_create(&amp;detach_th, &amp;attr, th_fn, (<span class="keyword">void</span>*)<span class="number">100</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread create error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_join(default_th, (<span class="keyword">void</span>*)&amp;res)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, strerror(err));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"default return is %d\n"</span>, (<span class="keyword">int</span>)res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>Thread and signal</p>
<ul>
<li><p>A process’s signal is shared by all its threads, and each thread has its own signal mask and pending word. For example, a timer is a process resource, and all threads in the process share the same timer.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the child thread calls alarm() to send alarm signal to the main thread by default</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pthread id in the sig_handler: %lx\n"</span>, pthread_self());</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGALRM) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"timeout...\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">th_fn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGALRM, sig_handler);</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"(%lx) i: %d\n"</span>, pthread_self(), i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> th;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;th, &amp;attr, th_fn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"control thread(%lx) is runing...\n"</span>, pthread_self());</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"control thread over\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);</code>: fetch and/or change the signal mask of the calling thread. The signal mask is the set of signals whose delivery is currently blocked for the caller. On success, it returns 0; on error, it returns an error number.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use pthread_sigmask to mask signal in the current thread</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pthread id in the sig_handler: %lx\n"</span>, pthread_self());</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGALRM) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"timeout...\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">th_fn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGALRM, sig_handler);</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"(%lx) i: %d\n"</span>, pthread_self(), i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> th;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;th, &amp;attr, th_fn, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGALRM);</span><br><span class="line">    pthread_sigmask(SIG_SETMASK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"control thread(%lx) is runing...\n"</span>, pthread_self());</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"control thread over\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="Thread-Mutex"><a href="#Thread-Mutex" class="headerlink" title="Thread Mutex"></a>Thread Mutex</h2><h3 id="Concept-of-Thread-Mutex"><a href="#Concept-of-Thread-Mutex" class="headerlink" title="Concept of Thread Mutex"></a>Concept of Thread Mutex</h3><ol>
<li>Also known as direct constraint relationship, a lock or mutex (from mutual exclusion) is a synchronization mechanism for enforcing limits on access to a resource in an environment where there are many threads of execution. A lock is designed to enforce a mutual exclusion concurrency control policy. </li>
<li>Usually, three methods are used to solve it as below.<ul>
<li>the metux lock</li>
<li>the read-write lock</li>
<li>the thread semaphore</li>
</ul>
</li>
</ol>
<h3 id="Metux-Lock"><a href="#Metux-Lock" class="headerlink" title="Metux Lock"></a>Metux Lock</h3><ol>
<li>Concept of the metux lock: a simple locking method to control access to a shared resource. At the same time there is only one thread to master a mutex to the shared resource. If another thread wants to access the shared resources, it is suspended until the locked thread releases the mutex.</li>
<li><p>Initialization and destruction of a mutex lock</p>
<ul>
<li><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code>: shall initialize the mutex referenced by <em>mutex</em> with attributes specified by <em>attr</em>. If <em>attr</em> is NULL, the default mutex attributes are used.</li>
<li><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code>: shall destroy the mutex object referenced by <em>mutex</em>; the mutex object becomes, in effect, uninitialized. An implementation may cause it to set the object referenced by <em>mutex</em> to an invalid value.</li>
<li>If successful, they shall return zero; otherwise, an error number shall be returned to indicate the error.</li>
</ul>
</li>
<li><p>Lock and unlock of a mutex lock</p>
<ul>
<li><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code>: The mutex object referenced by <em>mutex</em> shall be locked by a call to <u>pthread_mutex_lock</u>(). If the mutex is already locked by another thread, the calling thread shall block until the mutex becomes available.</li>
<li><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code>: shall be equivalent to <u>pthread_mutex_lock</u>(), except that if the mutex object referenced by <em>mutex</em> is currently locked (by any thread, including the current thread), the call shall return immediately.</li>
<li><code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code>: shall release the mutex object referenced by <em>mutex</em>. The manner in which a mutex is released is dependent upon the mutex’s type attribute.</li>
<li>If successful, they shall return zero; otherwise, an error number shall be returned to indicate the error.</li>
</ul>
</li>
<li><p>Type attribute of a mutex lock</p>
<ul>
<li><p><code>int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict attr, int *restrict type);</code>: get the mutex type attribute.</p>
</li>
<li><p><code>int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);</code>: set the mutex type attribute.</p>
</li>
<li><p>Upon successful completion, the <u>pthread_mutexattr_gettype</u>() function shall return zero and store the value of the type attribute of attr into the object referenced by the type parameter. Otherwise, an error shall be returned to indicate the error. If successful, the <u>pthread_mutexattr_settype</u>() function shall return zero; otherwise, an error number shall be returned to indicate the error.</p>
</li>
<li><p>The type of mutex is contained in the type attribute of the mutex attributes. Valid mutex types include.</p>
<ul>
<li><p><strong>PTHREAD_MUTEX_NORMAL</strong>: lock successfully at first, but the thread to lock will block then.</p>
</li>
<li><p><strong>PTHREAD_MUTEX_ERRORCHECK</strong>: lock successfully at first, and lock successfully at second with counting inside.</p>
</li>
<li><p><strong>PTHREAD_MUTEX_RECURSIVE</strong>: lock successfully at first, then error occurs at second.</p>
</li>
<li><p><strong>PTHREAD_MUTEX_DEFAULT</strong>: be the same as <strong>PTHREAD_MUTEX_NORMAL</strong>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// three type of mutex attribute</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-usage:%s [error|normal|recursive]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> mutexattr;</span><br><span class="line">    pthread_mutexattr_init(&amp;mutexattr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"recursive"</span>)) &#123;</span><br><span class="line">        pthread_mutexattr_settype(&amp;mutexattr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"error"</span>)) &#123;</span><br><span class="line">        pthread_mutexattr_settype(&amp;mutexattr, PTHREAD_MUTEX_ERRORCHECK);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pthread_mutexattr_settype(&amp;mutexattr, PTHREAD_MUTEX_NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, &amp;mutexattr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_lock(&amp;mutex) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"lock failure\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"lock success\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_lock(&amp;mutex) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"lock failure\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"lock success\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_mutexattr_destroy(&amp;mutexattr);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Read-write-Lock"><a href="#Read-write-Lock" class="headerlink" title="Read-write Lock"></a>Read-write Lock</h3><ol>
<li>Concept of the read-write lock: a special spin lock that divides visitors to a shared resource into readers and writers, who only have read access to the shared resource, and writers who need to write to the shared resource. Allows multiple readers to access shared resources simultaneously, the maximum possible number of readers being the actual logical <strong>CPU</strong> number. Writers are exclusive. A read-write lock can only have one writer or multiple readers at the same time.</li>
<li><p>Initialization and destruction of a read-write lock</p>
<ul>
<li><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code>: allocate any resources required to use the read-write lock referenced by <em>rwlock</em> and initializes the lock to an unlocked state with attributes referenced by <em>attr</em>.</li>
<li><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code>: destroy the read-write lock object referenced by <em>rwlock</em> and release any resources used by the lock.</li>
<li>If successful, they shall return zero; otherwise, an error number shall be returned to indicate the error.</li>
</ul>
</li>
<li><p>Lock and unlock of a read-write lock</p>
<ul>
<li><p><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code>: apply a read lock to the read-write lock referenced by <em>rwlock</em>.</p>
</li>
<li><p><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code>: apply a write lock to the read-write lock referenced by <em>rwlock</em>.</p>
</li>
<li><p><code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code>: release a lock held on the read-write lock object referenced by <em>rwlock</em>.</p>
</li>
<li><p>If successful, they shall return zero; otherwise, an error number shall be returned to indicate the error.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test read-write lock</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-usage:%s [r|w] [r|w]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"r"</span>, argv[<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_rwlock_rdlock(&amp;rwlock) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"first read lock failure\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"first read lock success\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"w"</span>, argv[<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_rwlock_wrlock(&amp;rwlock) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"first write lock failure\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"first write lock success\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"r"</span>, argv[<span class="number">2</span>])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_rwlock_rdlock(&amp;rwlock) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"second read lock failure\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"second read lock success\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"w"</span>, argv[<span class="number">2</span>])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_rwlock_wrlock(&amp;rwlock) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"second write lock failure\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"second write lock success\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">    pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="Thread-synchronization"><a href="#Thread-synchronization" class="headerlink" title="Thread synchronization"></a>Thread synchronization</h2><h3 id="Concept-of-Thread-Synchronization"><a href="#Concept-of-Thread-Synchronization" class="headerlink" title="Concept of Thread Synchronization"></a>Concept of Thread Synchronization</h3><ol>
<li>Thread synchronization is defined as a mechanism which ensures that two or more concurrent processes or threads do not simultaneously execute some particular program segment known as critical section. Processes’ access to critical section is controlled by using synchronization techniques. When one thread starts executing the critical section (serialized segment of the program) the other thread should wait until the first thread finishes. If proper synchronization techniques are not applied, it may cause a race condition where the values of variables may be unpredictable and vary depending on the timings of context switches of the processes or threads.</li>
<li>For example, suppose that there are three processes, namely 1, 2, and 3. All three of them are concurrently executing, and they need to share a common resource (critical section) as shown in Figure 1. Synchronization should be used here to avoid any conflicts for accessing this shared resource. Hence, when Process 1 and 2 both try to access that resource, it should be assigned to only one process at a time. If it is assigned to Process 1, the other process (Process 2) needs to wait until Process 1 frees that resource</li>
<li>Another synchronization requirement which needs to be considered is the order in which particular processes or threads should be executed. Other than mutual exclusion, synchronization also deals with the following.<ul>
<li>Deadlock, which occurs when many processes are waiting for a shared resource (critical section) which is being held by some other process. In this case, the processes just keep waiting and execute no further;</li>
<li>Starvation, which occurs when a process is waiting to enter the critical section, but other processes monopolize the critical section, and the first process is forced to wait indefinitely;</li>
<li>Priority inversion, which occurs when a high-priority process is in the critical section, and it is interrupted by a medium-priority process. This violation of priority rules can happen under certain circumstances and may lead to serious consequences in real-time systems;</li>
<li>Busy waiting, which occurs when a process frequently polls to determine if it has access to a critical section. This frequent polling robs processing time from other processes.</li>
</ul>
</li>
<li>Usually, three methods are used to solve it as below:<ul>
<li>the condition variables</li>
<li>the thread semaphore</li>
</ul>
</li>
</ol>
<h3 id="Condition-Variable"><a href="#Condition-Variable" class="headerlink" title="Condition Variable"></a>Condition Variable</h3><ol>
<li><p>Concept of the condition variables: a mechanism to synchronize by using the shared global variable between threads. It mainly includes two actions: a thread waiting for condition variable’s condition to be true and hangs at the same time; Another thread makes the condition true. To prevent contention, the use of condition variables is always combined with a mutex lock.</p>
</li>
<li><p>Initialization and destruction of a condition variable:</p>
<ul>
<li><code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code>: initialize the condition variable referenced by <em>cond</em> with attributes referenced by <em>attr</em>.</li>
<li><code>int pthread_cond_destroy(pthread_cond_t *cond);</code>: destroy the given condition variable specified by <em>cond</em>; the object becomes, in effect, uninitialized.</li>
<li>If successful, they shall return zero; otherwise, an error number shall be returned to indicate the error.</li>
</ul>
</li>
<li><p>Wait function of a condition variable:</p>
<ul>
<li><code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code>: block on a condition variable. The application shall ensure that these functions are called with <em>mutex</em> locked by the calling thread; otherwise, an error or undefined behavior results.</li>
<li><code>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</code>: block on a condition variable, except that an error is returned if the absolute time specified by <em>abstime</em> passes (that is, system time equals or exceeds <em>abstime</em>) before the condition <em>cond</em> is signaled or broadcasted, or if the absolute time specified by <em>abstime</em> has already been passed at the time of the call.</li>
<li>Upon successful completion, a value of zero shall be returned; otherwise, an error number shall be returned to indicate the error.</li>
</ul>
</li>
<li><p>Signal function of a condition variable:</p>
<ul>
<li><p><code>int pthread_cond_signal(pthread_cond_t *cond);</code>: unblock at least one of the threads that are blocked on the specified condition variable <em>cond</em> (if any threads are blocked on <em>cond</em>).</p>
</li>
<li><p><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code>: unblock all threads currently blocked on the specified condition variable <em>cond</em>.</p>
</li>
<li><p>If successful, they shall return zero; otherwise, an error number shall be returned to indicate the error.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test condition variable</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">int</span> counter;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">&#125; Result;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">set_fn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    Result* r = (Result*)arg;</span><br><span class="line">    r-&gt;res = sum;</span><br><span class="line">    pthread_mutex_lock(&amp;r-&gt;mutex);</span><br><span class="line">    <span class="keyword">while</span> (r-&gt;counter &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;r-&gt;mutex);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">        pthread_mutex_lock(&amp;r-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;r-&gt;mutex);</span><br><span class="line">    pthread_cond_broadcast(&amp;r-&gt;cond);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">get_fn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Result* r = (Result*)arg;</span><br><span class="line">    pthread_mutex_lock(&amp;r-&gt;mutex);</span><br><span class="line">    r-&gt;counter++;</span><br><span class="line"></span><br><span class="line">    pthread_cond_wait(&amp;r-&gt;cond, &amp;r-&gt;mutex);</span><br><span class="line">    pthread_mutex_unlock(&amp;r-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = r-&gt;res;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0x%lx get sum is %d\n"</span>, pthread_self(), res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> cal, get1, get2;</span><br><span class="line"></span><br><span class="line">    Result r;</span><br><span class="line">    r.counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pthread_cond_init(&amp;r.cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;r.mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_create(&amp;get1, <span class="literal">NULL</span>, get_fn, (<span class="keyword">void</span>*)&amp;r)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread create error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_create(&amp;get2, <span class="literal">NULL</span>, get_fn, (<span class="keyword">void</span>*)&amp;r)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread create error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_create(&amp;cal, <span class="literal">NULL</span>, set_fn, (<span class="keyword">void</span>*)&amp;r)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread create error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(get1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(get2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cal, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cond_destroy(&amp;r.cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;r.mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Reader and writer question</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one reader and one writer</span></span><br><span class="line">   </span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">       <span class="keyword">int</span> value;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">pthread_cond_t</span> rc;</span><br><span class="line">       <span class="keyword">pthread_mutex_t</span> rm;</span><br><span class="line">       <span class="keyword">int</span> r_wait;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">pthread_cond_t</span> wc;</span><br><span class="line">       <span class="keyword">pthread_mutex_t</span> wm;</span><br><span class="line">       <span class="keyword">int</span> w_wait;</span><br><span class="line">   </span><br><span class="line">   &#125; Storage;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">set_data</span><span class="params">(Storage* p, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       p-&gt;value = value;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">get_data</span><span class="params">(Storage* p)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> p-&gt;value;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span>* <span class="title">set_th</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       Storage* p = (Storage*)arg;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">           set_data(p, i);</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"0x%lx write data: %d\n"</span>, pthread_self(), i);</span><br><span class="line">           pthread_mutex_lock(&amp;p-&gt;rm);</span><br><span class="line">           <span class="keyword">while</span> (!p-&gt;r_wait) &#123;</span><br><span class="line">               pthread_mutex_unlock(&amp;p-&gt;rm);</span><br><span class="line">               sleep(<span class="number">1</span>);</span><br><span class="line">               pthread_mutex_lock(&amp;p-&gt;rm);</span><br><span class="line">           &#125;</span><br><span class="line">           p-&gt;r_wait = <span class="number">0</span>;</span><br><span class="line">           pthread_mutex_unlock(&amp;p-&gt;rm);</span><br><span class="line">           pthread_cond_broadcast(&amp;p-&gt;rc);</span><br><span class="line">   </span><br><span class="line">           pthread_mutex_lock(&amp;p-&gt;wm);</span><br><span class="line">           p-&gt;w_wait = <span class="number">1</span>;</span><br><span class="line">           pthread_cond_wait(&amp;p-&gt;wc, &amp;p-&gt;wm);</span><br><span class="line">           pthread_mutex_unlock(&amp;p-&gt;wm);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span>* <span class="title">get_th</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       Storage* p = (Storage*)arg;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">           pthread_mutex_lock(&amp;p-&gt;rm);</span><br><span class="line">           p-&gt;r_wait = <span class="number">1</span>;</span><br><span class="line">           pthread_cond_wait(&amp;p-&gt;rc, &amp;p-&gt;rm);</span><br><span class="line">           pthread_mutex_unlock(&amp;p-&gt;rm);</span><br><span class="line">           <span class="keyword">int</span> value = get_data(p);</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"0x%lx read data: %d\n"</span>, pthread_self(), value);</span><br><span class="line">   </span><br><span class="line">           pthread_mutex_lock(&amp;p-&gt;wm);</span><br><span class="line">           <span class="keyword">while</span> (!p-&gt;w_wait) &#123;</span><br><span class="line">               pthread_mutex_unlock(&amp;p-&gt;wm);</span><br><span class="line">               sleep(<span class="number">1</span>);</span><br><span class="line">               pthread_mutex_lock(&amp;p-&gt;wm);</span><br><span class="line">           &#125;</span><br><span class="line">           p-&gt;w_wait = <span class="number">0</span>;</span><br><span class="line">           pthread_mutex_unlock(&amp;p-&gt;wm);</span><br><span class="line">           pthread_cond_broadcast(&amp;p-&gt;wc);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> err;</span><br><span class="line">       <span class="keyword">pthread_t</span> rth, wth;</span><br><span class="line">   </span><br><span class="line">       Storage s;</span><br><span class="line">       <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">       pthread_mutex_init(&amp;s.rm, <span class="literal">NULL</span>);</span><br><span class="line">       pthread_mutex_init(&amp;s.wm, <span class="literal">NULL</span>);</span><br><span class="line">       pthread_cond_init(&amp;s.rc, <span class="literal">NULL</span>);</span><br><span class="line">       pthread_cond_init(&amp;s.wc, <span class="literal">NULL</span>);</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">if</span> ((err = pthread_create(&amp;rth, <span class="literal">NULL</span>, get_th, (<span class="keyword">void</span>*)&amp;s)) != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"thread create error\n"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((err = pthread_create(&amp;wth, <span class="literal">NULL</span>, set_th, (<span class="keyword">void</span>*)&amp;s)) != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"thread create error\n"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       pthread_join(rth, <span class="literal">NULL</span>);</span><br><span class="line">       pthread_join(wth, <span class="literal">NULL</span>);</span><br><span class="line">   </span><br><span class="line">       pthread_mutex_destroy(&amp;s.rm);</span><br><span class="line">       pthread_mutex_destroy(&amp;s.wm);</span><br><span class="line">       pthread_cond_destroy(&amp;s.rc);</span><br><span class="line">       pthread_cond_destroy(&amp;s.wc);</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Thread-Semaphore"><a href="#Thread-Semaphore" class="headerlink" title="Thread Semaphore"></a>Thread Semaphore</h2><h3 id="Concept-of-Thread-Semaphore"><a href="#Concept-of-Thread-Semaphore" class="headerlink" title="Concept of Thread Semaphore"></a>Concept of Thread Semaphore</h3><ol>
<li>A non-negative integer (number of the shared resources) that will be subtracts by all threads/processes getting it, and when the integer value is zero, all threads trying to apply it will be in a waiting state. Usually, we define two operations on it: wait and post. When a thread calls wait, it either gets the resource and subtracts the semaphore by one or waits until the semaphore is greater than or equal to one. Post is actually doing the addition on the semaphore.</li>
<li>Semaphores are a useful tool in the prevention of race conditions; however, their use is by no means a guarantee that a program is free from these problems. Semaphores which allow an arbitrary resource count are called counting semaphores, while semaphores which are restricted to the values 0 and 1 (or locked/unlocked, unavailable/available) are called binary semaphores and are used to implement locks.</li>
</ol>
<h3 id="Usage-of-Thread-Semaphore"><a href="#Usage-of-Thread-Semaphore" class="headerlink" title="Usage of Thread Semaphore"></a>Usage of Thread Semaphore</h3><ol>
<li>Initialization and destruction of a thread semaphore:<ul>
<li><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code>: initializes the unnamed semaphore at the address pointed to by <em>sem</em>. The <em>value</em> argument specifies the initial value for the semaphore. The <em>pshared</em> argument indicates whether this semaphore is to be shared between the threads of a process, or between processes.</li>
<li><code>int sem_destroy(sem_t *sem);</code>: destroys the unnamed semaphore at the address pointed to by <em>sem</em>.</li>
<li>They returns 0 on success; on error, -1 is returned, and <em>errno</em> is set to indicate the error.</li>
</ul>
</li>
<li>Addition and subtraction of a thread semaphore<ul>
<li><code>int sem_post(sem_t *sem);</code>: increments (unlocks) the semaphore pointed to by <em>sem</em>. If the semaphore’s value consequently becomes greater than zero, then another process or thread blocked in a <u>sem_wait</u>() call will be woken up and proceed to lock the semaphore.</li>
<li><code>int sem_wait(sem_t *sem);</code>: decrements (locks) the semaphore pointed to by <em>sem</em>. If the semaphore’s value is greater than zero, then the decrement proceeds, and the function returns, immediately. If the semaphore currently has the value zero, then the call blocks until either it becomes possible to perform the decrement (i.e., the semaphore value rises above zero), or a signal handler interrupts the call.</li>
<li><code>int sem_trywait(sem_t *sem);</code>: the same as <u>sem_wait</u>(), except that if the decrement cannot be immediately performed, then call returns an error instead of blocking.</li>
<li>They return 0 on success; on error, the value of the semaphore is left unchanged, -1 is returned, and errno is set to indicate the error.</li>
</ul>
</li>
<li>Use the semaphore to implement the thread synchronization and mutex<ul>
<li>Mutex: set semaphore initial value is a positive integer</li>
<li>Synchronization: set semaphore initial value is zero </li>
</ul>
</li>
</ol>
<h3 id="Deadlock"><a href="#Deadlock" class="headerlink" title="Deadlock"></a>Deadlock</h3><ol>
<li><p>Concept of deadlock: it occurs when a process or thread enters a waiting state because a requested system resource is held by another waiting process, which in turn is waiting for another resource held by another waiting process. If a process is unable to change its state indefinitely because the resources requested by it are being used by another waiting process, then the system is said to be in a deadlock.</p>
</li>
<li><p>Necessary condition that deadlock occur</p>
<ul>
<li>Mutual exclusion: At least one resource must be held in a non-shareable mode. Otherwise, the processes would not be prevented from using the resource when necessary. Only one process can use the resource at any given instant of time.</li>
<li>No preemption: a resource can be released only voluntarily by the process holding it.</li>
<li>Hold and wait or resource holding: a process is currently holding at least one resource and requesting additional resources which are being held by other processes.</li>
<li>Circular waiting: each process must be waiting for a resource which is being held by another process, which in turn is waiting for the first process to release the resource. In general, there is a set of waiting processes, $P= { P_1,P_2,…,P_n }$ such that $P_1$ is waiting for a resource held by $P_2$, $P_2$ is waiting for a resource held by $P_3$ and so on until $P_n$ is waiting for a resource held by $P_1$.</li>
</ul>
</li>
<li><p>Deadlock handling</p>
<ul>
<li>Ignoring deadlock: In this approach, it is assumed that a deadlock will never occur. This is also an application of the Ostrich algorithm. This approach was initially used by <strong>MINIX</strong> and <strong>UNIX</strong>. This is used when the time intervals between occurrences of deadlocks are large and the data loss incurred each time is tolerable.</li>
<li>Detection: Under the deadlock detection, deadlocks are allowed to occur. Then the state of the system is examined to detect that a deadlock has occurred and subsequently it is corrected. An algorithm is employed that tracks resource allocation and process states, it rolls back and restarts one or more of the processes in order to remove the detected deadlock. Detecting a deadlock that has already occurred is easily possible since the resources that each process has locked and/or currently requested are known to the resource scheduler of the operating system.<ul>
<li>Process termination: one or more processes involved in the deadlock may be aborted. One could choose to abort all competing processes involved in the deadlock. This ensures that deadlock is resolved with certainty and speed. But the expense is high as partial computations will be lost. Or, one could choose to abort one process at a time until the deadlock is resolved. This approach has high overhead because after each abort an algorithm must determine whether the system is still in deadlock. Several factors must be considered while choosing a candidate for termination, such as priority and age of the process.</li>
<li>Resource preemption: resources allocated to various processes may be successively preempted and allocated to other processes until the deadlock is broken.</li>
</ul>
</li>
<li>Prevention: deadlock prevention works by preventing one of the four Coffman conditions from occurring.<ul>
<li>Removing the mutual exclusion condition means that no process will have exclusive access to a resource. This proves impossible for resources that cannot be spooled. But even with spooled resources, deadlock could still occur. Algorithms that avoid mutual exclusion are called non-blocking synchronization algorithms.</li>
<li>The hold and wait or resource holding conditions may be removed by requiring processes to request all the resources they will need before starting up (or before embarking upon a particular set of operations). This advance knowledge is frequently difficult to satisfy and, in any case, is an inefficient use of resources. Another way is to require processes to request resources only when it has none. Thus, first they must release all their currently held resources before requesting all the resources they will need from scratch. This too is often impractical. It is so because resources may be allocated and remain unused for long periods. Also, a process requiring a popular resource may have to wait indefinitely, as such a resource may always be allocated to some process, resulting in resource starvation. (These algorithms, such as serializing tokens, are known as the all-or-none algorithms.)</li>
<li>The no preemption condition may also be difficult or impossible to avoid as a process has to be able to have a resource for a certain amount of time, or the processing outcome may be inconsistent or thrashing may occur. However, inability to enforce preemption may interfere with a priority algorithm. Preemption of a “locked out” resource generally implies a rollback, and is to be avoided, since it is very costly in overhead. Algorithms that allow preemption include lock-free and wait-free algorithms and optimistic concurrency control. If a process holding some resources and requests for some another resource(s) that cannot be immediately allocated to it, the condition may be removed by releasing all the currently being held resources of that process.</li>
<li>The final condition is the circular wait condition. Approaches that avoid circular waits include disabling interrupts during critical sections and using a hierarchy to determine a partial ordering of resources. If no obvious hierarchy exists, even the memory address of resources has been used to determine ordering and resources are requested in the increasing order of the enumeration. <strong>Banker algorithm</strong> can also be used.</li>
</ul>
</li>
</ul>
</li>
</ol>

    </div>

    
    
    
      <div style="text-align:center;color: #ccc;font-size:14px;">---------------- The End ----------------</div>
        
      
        <div id="reward-container">
  <div>Donate comment here.</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.png" alt="YiHe Huang WeChat Pay">
        <p>WeChat Pay</p>
      </div>
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.png" alt="YiHe Huang Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>

      
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>YiHe Huang</li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="http://youthfaith.cn/2019/04/07/ThreadManagement/" title="Thread Management">http://youthfaith.cn/2019/04/07/ThreadManagement/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.</li>
<li>
     <strong>No reproduction without permission.</strong>
</li>
</ul>
</div>

      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/Ultimate-Knowledge/" rel="tag"><i class="fa fa-tag"></i> Ultimate Knowledge</a>
            
              <a href="/tags/OS-System/" rel="tag"><i class="fa fa-tag"></i> OS System</a>
            
              <a href="/tags/C-Language/" rel="tag"><i class="fa fa-tag"></i> C Language</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/03/07/PosixSignal/" rel="next" title="POSIX Signal">
                  <i class="fa fa-chevron-left"></i> POSIX Signal
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/07/01/MyShellAndVim/" rel="prev" title="My Shell and Vim Editor">
                  My Shell and Vim Editor <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          
    
    <div class="comments" id="gitalk-container"></div>
  

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc" data-target="post-toc-wrap">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview-wrap">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread"><span class="nav-number">1.</span> <span class="nav-text">Thread</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Concept-of-Thread"><span class="nav-number">1.1.</span> <span class="nav-text">Concept of Thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-vs-Process"><span class="nav-number">1.2.</span> <span class="nav-text">Thread vs. Process</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-Model"><span class="nav-number">1.3.</span> <span class="nav-text">Thread Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-Creation"><span class="nav-number">1.4.</span> <span class="nav-text">Thread Creation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-Termination"><span class="nav-number">1.5.</span> <span class="nav-text">Thread Termination</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-Attribution"><span class="nav-number">1.6.</span> <span class="nav-text">Thread Attribution</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-Mutex"><span class="nav-number">2.</span> <span class="nav-text">Thread Mutex</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Concept-of-Thread-Mutex"><span class="nav-number">2.1.</span> <span class="nav-text">Concept of Thread Mutex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Metux-Lock"><span class="nav-number">2.2.</span> <span class="nav-text">Metux Lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-write-Lock"><span class="nav-number">2.3.</span> <span class="nav-text">Read-write Lock</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-synchronization"><span class="nav-number">3.</span> <span class="nav-text">Thread synchronization</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Concept-of-Thread-Synchronization"><span class="nav-number">3.1.</span> <span class="nav-text">Concept of Thread Synchronization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition-Variable"><span class="nav-number">3.2.</span> <span class="nav-text">Condition Variable</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread-Semaphore"><span class="nav-number">4.</span> <span class="nav-text">Thread Semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Concept-of-Thread-Semaphore"><span class="nav-number">4.1.</span> <span class="nav-text">Concept of Thread Semaphore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Usage-of-Thread-Semaphore"><span class="nav-number">4.2.</span> <span class="nav-text">Usage of Thread Semaphore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Deadlock"><span class="nav-number">4.3.</span> <span class="nav-text">Deadlock</span></a></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.gif"
      alt="YiHe Huang">
  <p class="site-author-name" itemprop="name">YiHe Huang</p>
  <div class="site-description" itemprop="description">YouthFaith's Blog</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/YouthFaith" title="GitHub &rarr; https://github.com/YouthFaith" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:huangyihe52647849@gmail.com" title="E-Mail &rarr; mailto:huangyihe52647849@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://twitter.com/youthfaith1" title="Twitter &rarr; https://twitter.com/youthfaith1" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
    
  </div>
  <div class="cc-license motion-element" itemprop="license">
    
  
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://dzblog.cn" title="https://dzblog.cn" rel="noopener" target="_blank">Wintermelon's Blog</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://crossoverjie.top" title="https://crossoverjie.top" rel="noopener" target="_blank">crossoverJie's Blog</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://yangbingdong.com" title="https://yangbingdong.com" rel="noopener" target="_blank">ookamiAntD's Blog</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://xiaozhou.net/" title="https://xiaozhou.net/" rel="noopener" target="_blank">Timothy's Blog</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://zww.me" title="https://zww.me" rel="noopener" target="_blank">ZWWoOoOo's Blog</a>
        </li>
      
        <li class="links-of-blogroll-item">
          <a href="https://www.jitwxs.cn/" title="https://www.jitwxs.cn/" rel="noopener" target="_blank">Jitwxs's Blog</a>
        </li>
      
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YiHe Huang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="Symbols count total">218k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">3:18</span>
</div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="Total Visitors">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  
    <span class="post-meta-divider">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="Total Views">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>












        
      </div>
    </footer>
  </div>

  
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='158' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/muse.js?v=7.3.0"></script>
<script src="/js/next-boot.js?v=7.3.0"></script>



  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>








  <script src="/js/local-search.js?v=7.3.0"></script>














  

  
    
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    
  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: 'a78a0cd3150929e4d6b0',
      clientSecret: '6f4f19733838d199a701705a5c56ac19b2c029ce',
      repo: 'youthfaith-talk',
      owner: 'YouthFaith',
      admin: ['YouthFaith'],
      id: '31e236160eaa670482cb522f76a0345f',
        language: 'en',
      
      distractionFreeMode: 'false'
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
</script>

  <script type="text/javascript" src="/js/src/clipboard.min.js"></script>  
  <script type="text/javascript" src="/js/src/clipboard-use.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"superSample":2,"width":150,"height":230,"position":"right"},"mobile":{"show":true},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});</script></body>
</html>
