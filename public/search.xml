<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Network Programming</title>
      <link href="/2019/10/07/NetworkProgramming/"/>
      <url>/2019/10/07/NetworkProgramming/</url>
      
        <content type="html"><![CDATA[<h2 id="Internetwork-Data-Communication"><a href="#Internetwork-Data-Communication" class="headerlink" title="Internetwork Data Communication"></a>Internetwork Data Communication</h2><h3 id="Endianness"><a href="#Endianness" class="headerlink" title="Endianness"></a>Endianness</h3><ol><li><p>Concept of endianness: endianness refers to the order of bytes (or sometimes bits) within a binary representation of a number. It can also be used more generally to refer to the internal ordering of any representation, such as the digits in a numeral system or the sections of a date. In its most common usage, endianness indicates the ordering of bytes within a multi-byte number. A big-endian ordering places the most significant byte first and the least significant byte last, while a little-endian ordering does the opposite. For example, consider the unsigned hexadecimal number <code>0x1234</code>, which requires at least two bytes to represent. In a big-endian ordering they would be <code>[ 0x12, 0x34 ]</code>, while in a little-endian ordering, the bytes would be arranged <code>[ 0x34, 0x12 ]</code>.</p><a id="more"></a></li><li><p>Many <strong>IETF RFCs</strong> use the term network order, meaning the order of transmission for bits and bytes over the wire in network protocols. Among others, the historic <strong>RFC 1700</strong> has defined the network order for protocols in the Internet protocol suite to be big-endian, hence the use of the term “network byte order” for big-endian byte order.</p></li><li><p>Some common function to convert values between host and network byte order</p><ul><li><code>uint32_t htonl(uint32_t hostlong);</code>: converts the unsigned integer <em>hostlong</em> from host byte order to network byte order.</li><li><code>uint32_t ntohl(uint32_t netlong);</code>: converts the unsigned integer <em>netlong</em> from network byte order to host byte order.</li><li><code>uint16_t htons(uint16_t hostshort);</code>: converts the unsigned short integer <em>hostshort</em> from host byte order to network byte order.</li><li><code>uint16_t ntohs(uint16_t netshort);</code>: converts the unsigned short integer <em>netshort</em> from network byte order to host byte order.</li></ul></li></ol><h3 id="Network-Socket"><a href="#Network-Socket" class="headerlink" title="Network Socket"></a>Network Socket</h3><ol><li><p>Concept of socket: an internal endpoint for sending or receiving data within a node on a computer network. Concretely, it is a representation of this endpoint in networking software (protocol stack), such as an entry in a table (listing communication protocol, destination, status, etc.), and is a form of system resource. In the standard Internet protocols <strong>TCP</strong> and <strong>UDP</strong>, a socket address is the combination of an <strong>IP</strong> address and a port number, much like one end of a telephone connection is the combination of a phone number and a particular extension. Sockets need not have a source address, for example, for only sending data, but if a program <em>binds</em> a socket to a source address, the socket can be used to receive data sent to that address. Based on this address, Internet sockets deliver incoming data packets to the appropriate application process.</p></li><li><p>TCP client and server model</p><p><img src="/img/tcp_socket.png" alt="tcp_socket"></p></li><li><p>UDP client and server model</p><p><img src="/img/udp_socket.png" alt="udp_socket"></p></li><li><p>Some common function to convert the network addresses between binary and text form</p><ul><li><code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code>: convert the network address structure <em>src</em> in the <em>af</em> address family into a character string. The resulting string is copied to the buffer pointed to by <em>dst</em>, which must be a non-null pointer. The caller specifies the number of bytes available in this buffer in the argument <em>size</em>. On success, it returns a non-null pointer to <em>dst</em>. <strong>NULL</strong> is returned if there was an error, with <em>errno</em> set to indicate the error.</li><li><code>int inet_pton(int af, const char *src, void *dst);</code>: converts the character string <em>src</em> into a network address structure in the <em>af</em> address family, then copies the network address structure to <em>dst</em>. The af argument must be either <strong>AF_INET</strong> or <strong>AF_INET6</strong>. <em>dst</em> is written in network byte order. It returns 1 on success (network address was successfully converted). 0 is returned if <em>src</em> does not contain a character string representing a valid network address in the specified address family. If <em>af</em> does not contain a valid address family, -1 is returned and <em>errno</em> is set to <strong>EAFNOSUPPORT</strong>.</li></ul></li><li><p>Some common functions to establish the socket connection </p><ul><li><p><code>int socket(int domain, int type, int protocol);</code>: create an endpoint for communication and returns a file descriptor that refers to that endpoint. The <em>domain</em> argument specifies a communication domain. The <em>type</em> specifies the communication semantics. The <em>protocol</em> specifies a particular protocol to be used with the socket. On success, a file descriptor for the new socket is returned. On error, -1 is returned, and <em>errno</em> is set appropriately.</p><table style="text-align:center">    <tr>        <td style="color: blue" colspan="2">Domain</td>    </tr>    <tr>        <td>AF_INET</td>        <td>IPv4 Internet protocols</td>    </tr>    <tr>        <td>AF_INET6</td>        <td>IPv6 Internet protocols</td>    </tr>    <tr>        <td>AF_UNIX</td>        <td>Local communication</td>    </tr>    <tr>        <td style="color: blue" colspan="2">Type</td>    </tr>    <tr>        <td>SOCK_STREAM</td>        <td style="text-align:left">(TCP) Provides sequenced, reliable, two-way, connection-based byte streams. An out-of-band data transmission mechanism may be supported.</td>    </tr>    <tr>        <td>SOCK_DGRAM</td>        <td style="text-align:left">(UDP) Supports datagrams (connectionless, unreliable messages of a fixed maximum length).</td>    </tr>    <tr>        <td>SOCK_RAW</td>        <td style="text-align:left">Provides raw network protocol access.</td>    </tr>    <tr>        <td>SOCK_SEQPACKET</td>        <td style="text-align:left">Provides a sequenced, reliable, two-way connection-based data transmission path for datagrams of fixed maximum length; a consumer is required to read an entire packet with each input system call.</td>    </tr></table></li><li><p><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code>: assign the address specified by <em>addr</em> to the socket referred to by the file descriptor <em>sockfd</em>. <em>addrlen</em> specifies the size, in bytes, of the address structure pointed to by <em>addr</em>. Traditionally, this operation is called “assigning a name to a socket”. On success, zero is returned. On error, -1 is returned, and <em>errno</em> is set appropriately.</p></li><li><p><code>int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code>: return the current address to which the socket <em>sockfd</em> is bound, in the buffer pointed to by <em>addr</em>. The <em>addrlen</em> argument should be initialized to indicate the amount of space (in bytes) pointed to by <em>addr</em>. On success, zero is returned. On error, -1 is returned, and <em>errno</em> is set appropriately.</p></li><li><p><code>int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code>: return the address of the peer connected to the socket <em>sockfd</em>, in the buffer pointed to by <em>addr</em>. The <em>addrlen</em> argument should be initialized to indicate the amount of space pointed to by <em>addr</em>. On success, zero is returned. On error, -1 is returned, and <em>errno</em> is set appropriately.</p></li><li><p><code>int listen(int sockfd, int backlog);</code>: mark the socket referred to by <em>sockfd</em> as a passive socket. The <em>sockfd</em> argument is a file descriptor that refers to a socket of type <strong>SOCK_STREAM</strong> or <strong>SOCK_SEQPACKET</strong>. The <em>backlog</em> argument defines the maximum length to which the queue of pending connections for <em>sockfd</em> may grow. If a connection request arrives when the queue is full, the client may receive an error with an indication of <strong>ECONNREFUSED</strong> or, if the underlying protocol supports retransmission, the request may be ignored so that a later reattempt at connection succeeds. On success, zero is returned. On error, -1 is returned, and <em>errno</em> is set appropriately.</p></li><li><p><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code>: connects the socket referred to by the file descriptor sockfd to the address specified by <em>addr</em>. The <em>addrlen</em> argument specifies the size of <em>addr</em>. The format of the address in <em>addr</em> is determined by the address space of the socket <em>sockfd</em>. If the connection or binding succeeds, zero is returned. On error, -1 is returned, and <em>errno</em> is set appropriately.</p></li><li><p><code>ssize_t send(int sockfd, const void *buf, size_t len, int flags);</code>: be used only when the socket is in a connected state (so that the intended recipient is known). The only difference between <u>send</u>() and <u>write</u>() is the presence of <em>flags</em>. With a zero flags argument, <u>send</u>() is equivalent to <u>write</u>(). The argument <em>sockfd</em> is the file descriptor of the sending socket. On success, these calls return the number of bytes sent. On error, -1 is returned, and <em>errno</em> is set appropriately.</p></li><li><p><code>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);</code>: used on a connection-mode (<strong>SOCK_STREAM</strong>, <strong>SOCK_SEQPACKET</strong>) socket, the arguments <em>dest_addr</em> and <em>addrlen</em> are ignored (and the error <strong>EISCONN</strong> may be returned when they are not <strong>NULL</strong> and 0), and the error <strong>ENOTCONN</strong> is returned when the socket was not actually connected. Otherwise, the address of the target is given by <em>dest_addr</em> with <em>addrlen</em> specifying its size. On success, these calls return the number of bytes sent. On error, -1 is returned, and <em>errno</em> is set appropriately.</p></li><li><p><code>ssize_t recv(int sockfd, void *buf, size_t len, int flags);</code>: used to receive messages from a socket. They may be used to receive data on both connectionless and connection-oriented sockets. It returns the number of bytes received, or -1 if an error occurred. In the event of an error, <em>errno</em> is set to indicate the error.</p></li><li><p><code>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);</code>: place the received message into the buffer <em>buf</em>. The caller must specify the size of the buffer in <em>len</em>. If <em>src_addr</em> is not <strong>NULL</strong>, and the underlying protocol provides the source address of the message, that source address is placed in the buffer pointed to by <em>src_addr</em>. In this case, <em>addrlen</em> is a value-result argument. Before the call, it should be initialized to the size of the buffer associated with <em>src_addr</em>. Upon return, <em>addrlen</em> is updated to contain the actual size of the source address. The returned address is truncated if the buffer provided is too small; in this case, <em>addrlen</em> will return a value greater than was supplied to the call. It returns the number of bytes received, or -1 if an error occurred. In the event of an error, <em>errno</em> is set to indicate the error.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implement simple tcp end-to-end communication model</span></span><br><span class="line"><span class="comment">//src/time_tcp_server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_service</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> t = time(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span>* s = ctime(&amp;t);</span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="built_in">strlen</span>(s) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>);</span><br><span class="line">    write(fd, s, size);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_addr</span><span class="params">(struct sockaddr_in* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> port = ntohs(p-&gt;sin_port);</span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">memset</span>(ip, <span class="number">0</span>, <span class="keyword">sizeof</span>(ip));</span><br><span class="line">    inet_ntop(AF_INET, &amp;p-&gt;sin_addr.s_addr, ip, <span class="keyword">sizeof</span>(ip));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client: %s(%d) connected\n"</span>, ip, port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGINT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server close\n"</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s [port]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    signal(SIGINT, sig_handler);</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    bind(sockfd, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    listen(sockfd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = accept(sockfd, (struct sockaddr*)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line">        out_addr(&amp;client_addr);</span><br><span class="line">        do_service(fd);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//src/time_tcp_client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s [ip] [port]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;server_addr.sin_addr.s_addr);</span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"connect error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    <span class="keyword">size_t</span> size = read(sockfd, buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    write(STDOUT_FILENO, buff, size);</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>Implement custom communication protocol </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// implement custom communication protocol </span></span><br><span class="line"><span class="comment">//include/msg.h</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">ifndef</span> MSG_H_</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> MSG_H_</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     <span class="keyword">char</span> head[<span class="number">12</span>];</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> checknum;</span><br><span class="line">     <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line"> &#125; Msg;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">write_msg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">char</span>* buff, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">read_msg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">char</span>* buff, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> <span class="comment">//src/msg.c</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"msg.h"</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">msg_check</span><span class="params">(Msg* message)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> s = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(message-&gt;head); i++) &#123;</span><br><span class="line">         s += message-&gt;head[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(message-&gt;buff); i++) &#123;</span><br><span class="line">         s += message-&gt;buff[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> s;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">write_msg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">char</span>* buff, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     Msg message;</span><br><span class="line">     <span class="built_in">memset</span>(&amp;message, <span class="number">0</span>, <span class="keyword">sizeof</span>(message));</span><br><span class="line">     <span class="built_in">strcpy</span>(message.head, <span class="string">"YouthFaith"</span>);</span><br><span class="line">     <span class="built_in">memcpy</span>(message.buff, buff, len);</span><br><span class="line">     message.checknum = msg_check(&amp;message);</span><br><span class="line">     <span class="keyword">if</span> (write(sockfd, &amp;message, <span class="keyword">sizeof</span>(message)) != <span class="keyword">sizeof</span>(message)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">read_msg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">char</span>* buff, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     Msg message;</span><br><span class="line">     <span class="built_in">memset</span>(&amp;message, <span class="number">0</span>, <span class="keyword">sizeof</span>(message));</span><br><span class="line">     <span class="keyword">size_t</span> size;</span><br><span class="line">     <span class="keyword">if</span> ((size = read(sockfd, &amp;message, <span class="keyword">sizeof</span>(message))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> s = msg_check(&amp;message);</span><br><span class="line">     <span class="keyword">if</span> ((s == message.checknum) &amp;&amp; (!<span class="built_in">strcmp</span>(<span class="string">"YouthFaith"</span>, message.head))) &#123;</span><br><span class="line">         <span class="built_in">memcpy</span>(buff, message.buff, len);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">sizeof</span>(message);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//src/echo_tcp_client.c</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"msg.h"</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"usage: %s [ip] [port]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">     <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">     server_addr.sin_family = AF_INET;</span><br><span class="line">     server_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">     inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;server_addr.sin_addr.s_addr);</span><br><span class="line">     <span class="keyword">if</span> (connect(sockfd, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span></span><br><span class="line"> ) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"connect error\n"</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">     <span class="keyword">size_t</span> size;</span><br><span class="line">     <span class="keyword">char</span>* prompt = <span class="string">"&gt;"</span>;</span><br><span class="line">     <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">         <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">         write(STDOUT_FILENO, prompt, <span class="number">1</span>);</span><br><span class="line">         size = read(STDIN_FILENO, buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">         <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         buff[size - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">if</span> (write_msg(sockfd, buff, <span class="keyword">sizeof</span>(buff)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"write msg error\n"</span>);</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (read_msg(sockfd, buff, <span class="keyword">sizeof</span>(buff)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="built_in">printf</span>(<span class="string">"read msg error\n"</span>);</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buff);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     close(sockfd);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Multi-process TCP model</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implement multi-process tcp model</span></span><br><span class="line"><span class="comment">//src/echo_tcp_server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"msg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_info</span><span class="params">(<span class="keyword">char</span>* ip, <span class="keyword">int</span>* port, struct sockaddr_in* client_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *port = ntohs(client_addr-&gt;sin_port);</span><br><span class="line">    inet_ntop(AF_INET, &amp;client_addr-&gt;sin_addr.s_addr, ip, <span class="keyword">sizeof</span>(ip));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_servive</span><span class="params">(struct sockaddr_in* p, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">        <span class="keyword">size_t</span> size = read_msg(fd, buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> ip[<span class="number">16</span>] = <span class="string">"\0"</span>;</span><br><span class="line">        get_info(ip, &amp;port, p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"clent(%s:%d) send: %s\n"</span>, ip, port, buff);</span><br><span class="line">        <span class="keyword">if</span> (write_msg(fd, buff, <span class="keyword">sizeof</span>(buff)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EPIPE) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"protocol error\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_addr</span><span class="params">(struct sockaddr_in* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>] = <span class="string">"\0"</span>;</span><br><span class="line">    get_info(ip, &amp;port, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client: %s(%d) connected\n"</span>, ip, port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGINT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server close\n"</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGCHLD) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child process deaded...\n"</span>);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s [port]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    signal(SIGINT, sig_handler);</span><br><span class="line">    signal(SIGCHLD, sig_handler);</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="comment">//server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");</span></span><br><span class="line">    bind(sockfd, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    listen(sockfd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = accept(sockfd, (struct sockaddr*)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            out_addr(&amp;client_addr);</span><br><span class="line">            do_servive(&amp;client_addr, fd);</span><br><span class="line">            close(fd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Multi-thread TCP model</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implement multi-thread tcp model</span></span><br><span class="line"><span class="comment">//src/echo_tcp_server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"msg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_servive</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">        <span class="keyword">size_t</span> size = read_msg(fd, buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buff);</span><br><span class="line">        <span class="keyword">if</span> (write_msg(fd, buff, <span class="keyword">sizeof</span>(buff)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EPIPE) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"protocol error\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGINT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server close\n"</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_fd</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">    getpeername(fd, (struct sockaddr*)&amp;addr, &amp;len);</span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">memset</span>(ip, <span class="number">0</span>, <span class="keyword">sizeof</span>(ip));</span><br><span class="line">    <span class="keyword">int</span> port = ntohs(addr.sin_port);</span><br><span class="line">    inet_ntop(AF_INET, &amp;addr.sin_addr.s_addr, ip, <span class="keyword">sizeof</span>(ip));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%16s(%5d) closed!\n"</span>, ip, port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">th_fn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* fd = (<span class="keyword">int</span>*)arg;</span><br><span class="line">    do_servive(*fd);</span><br><span class="line">    out_fd(*fd);</span><br><span class="line">    close(*fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s [port]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    signal(SIGINT, sig_handler);</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    bind(sockfd, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    listen(sockfd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = accept(sockfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pthread_t</span> th;</span><br><span class="line">     pthread_create(&amp;th, &amp;attr, th_fn, (<span class="keyword">void</span>*)&amp;fd);</span><br><span class="line">        pthread_attr_destroy(&amp;attr);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Simple UDP model</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implement simple udp model</span></span><br><span class="line"><span class="comment">//src/time_udp_server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGINT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server close\n"</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_addr</span><span class="params">(struct sockaddr_in* client_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">memset</span>(ip, <span class="number">0</span>, <span class="keyword">sizeof</span>(ip));</span><br><span class="line">    inet_ntop(AF_INET, &amp;client_addr-&gt;sin_addr.s_addr, ip, <span class="keyword">sizeof</span>(ip));</span><br><span class="line">    <span class="keyword">int</span> port = ntohs(client_addr-&gt;sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client: %s(%d)\n"</span>, ip, port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_service</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    recvfrom(sockfd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>, (struct sockaddr*)&amp;client_addr, &amp;len</span><br><span class="line">);</span><br><span class="line">    out_addr(&amp;client_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client send info: %s\n"</span>, buff);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> t = time(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span>* ptr = ctime(&amp;t);</span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="built_in">strlen</span>(ptr) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>);</span><br><span class="line">    sendto(sockfd, ptr, size, <span class="number">0</span>, (struct sockaddr*)&amp;client_addr, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s [port]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    signal(SIGINT, sig_handler);</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    bind(sockfd, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        do_service();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//src/time_udp_client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s [ip] [port]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;server_addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>] = <span class="string">"hello, YouthFaith"</span>;</span><br><span class="line">    sendto(sockfd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span></span><br><span class="line">(server_addr));</span><br><span class="line">    <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    recv(sockfd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buff);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Name-resolution"><a href="#Name-resolution" class="headerlink" title="Name resolution"></a>Name resolution</h3><ol><li><p>Concept of name resolution: In computer systems, name resolution refers to the retrieval of the underlying numeric values corresponding to computer hostnames, account user names, group names, and other named entities. Computer operating systems commonly employ multiple key/value lists that associate easily remembered names with the integer numbers used to identify users, groups, other computers, hardware devices, and other entities. In that context, name resolution refers to the retrieval of numeric values given the associated names, while Reverse name resolution refers to the opposite process of finding the name(s) associated with specified numeric values. The <strong>GNU</strong> <strong>C</strong> library provides various operating system facilities that shell commands and other applications can call to resolve such names to the corresponding addresses or IDs, and vice versa.</p></li><li><p>Some function about name resolution</p><ul><li><p>The hostent structure is defined in <netdb.h> as follows:</netdb.h></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>* h_name; <span class="comment">/* official name of host */</span></span><br><span class="line"> <span class="keyword">char</span>** h_aliases; <span class="comment">/* alias list */</span></span><br><span class="line">    <span class="keyword">int</span> h_addrtype; <span class="comment">/* host address type */</span></span><br><span class="line"> <span class="keyword">int</span> h_length; <span class="comment">/* length of address */</span></span><br><span class="line">    <span class="keyword">char</span>** h_addr_list; <span class="comment">/* list of addresses */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ol><pre><code>    * `struct hostent *gethostent(void);`: return the next entry in the host data base. When using **DNS**/**BIND** this does not make much sense, but it may be reasonable if the host data base is a file that can be read line by line. On many systems, a routine of this name reads from the file &lt;u&gt;/etc/hosts&lt;/u&gt;. It may be available only when the library was built without **DNS** support. The **glibc** version will ignore ipv6 entries. This function is not reentrant, and glibc adds a reentrant version &lt;u&gt;gethostent\_r()&lt;/u&gt;. It returns the hostent structure or a null pointer if an error occurs.    * `struct hostent *gethostbyname(const char *name);`: return a structure of type hostent for the given host name. Here name is either a hostname or an IPv4 address in standard dot notation. If name is an IPv4 address, no lookup is performed and it simply copies name into the h_name field and its structure in_addr equivalent into the h_addr_list[0] field of the returned hostent structure. If name doesn&#39;t end in a dot and the environment variable **HOSTALIASES** is set, the alias file pointed to by **HOSTALIASES** will first be searched for name for the file format. The current domain and its parents are searched unless name ends in a dot. It returns the hostent structure or a null pointer if an error occurs.    * `void sethostent(int stayopen);`: specify, if *stayopen* is true, that a connected **TCP** socket should be used for the name server queries and that the connection should remain open during successive queries. Otherwise, name server queries will use **UDP** datagrams.    * `void endhostent(void);`: end the use of a **TCP** connection for name server queries.      <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//implement name resolution</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_addr</span><span class="params">(struct hostent* h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hostname: %s\n"</span>, h-&gt;h_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"addrtype: %s\n"</span>, h-&gt;h_addrtype == AF_INET ? <span class="string">"IPV4"</span> : <span class="string">"IPV6"</span>);</span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">memset</span>(ip, <span class="number">0</span>, <span class="keyword">sizeof</span>(ip));</span><br><span class="line">    inet_ntop(h-&gt;h_addrtype, h-&gt;h_addr_list[<span class="number">0</span>], ip, <span class="keyword">sizeof</span>(ip));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ip address: %s\n"</span>, ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (h-&gt;h_aliases[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"aliase: %s\n"</span>, h-&gt;h_aliases[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s [host]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>* <span class="title">h</span>;</span></span><br><span class="line">    h = gethostbyname(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        out_addr(h);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"no %s exist\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    endhostent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h3><ol><li><p>Common functions to manipulate options for the socket.</p><pre><code>       * `int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);`.       * `int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);`.</code></pre></li><li><p>Simple broadcast model</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implement simple broadcast model</span></span><br><span class="line"><span class="comment">//src/receiver.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGINT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"reveiver will exited\n"</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s [port]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    signal(SIGINT, sig_handler);</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    bind(sockfd, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">        <span class="built_in">memset</span>(&amp;client_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(client_addr));</span><br><span class="line">        recvfrom(sockfd, buff, <span class="keyword">sizeof</span>(buff), <span class="number">0</span>, (struct sockaddr*)&amp;client_addr, &amp;len);</span><br><span class="line">        <span class="keyword">char</span> ip[<span class="number">16</span>];</span><br><span class="line">        inet_ntop(AF_INET, &amp;client_addr.sin_addr.s_addr, ip, <span class="keyword">sizeof</span>(ip));</span><br><span class="line">        <span class="keyword">int</span> port = ntohs(client_addr.sin_port);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s(%d): %s\n"</span>, ip, port, buff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//src/broadcast.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s [ip] [port]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">    inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;server_addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* info = <span class="string">"hello YouthFaith\0"</span>;</span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="built_in">strlen</span>(info) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>);</span><br><span class="line">    sendto(sockfd, info, size, <span class="number">0</span>, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    close(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="I-O-multiplexing"><a href="#I-O-multiplexing" class="headerlink" title="I/O multiplexing"></a>I/O multiplexing</h2><h3 id="Dynamic-Array-for-Fd"><a href="#Dynamic-Array-for-Fd" class="headerlink" title="Dynamic Array for Fd"></a>Dynamic Array for Fd</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/vector.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> VECTOR_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VECTOR_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *fd;</span><br><span class="line">    <span class="keyword">int</span> counter;</span><br><span class="line">    <span class="keyword">int</span> max_counter;</span><br><span class="line">&#125;VectorFd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> VectorFd* <span class="title">create_vector_fd</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">destroy_vector_fd</span><span class="params">(VectorFd* vfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">get_fd</span><span class="params">(VectorFd* vfd, <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">remove_fd</span><span class="params">(VectorFd* vfd, <span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">add_fd</span><span class="params">(VectorFd* vfd, <span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//src/vector.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encapacity</span><span class="params">(VectorFd* vfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vfd-&gt;counter &gt;= vfd-&gt;max_counter) &#123;</span><br><span class="line">        vfd-&gt;fd = (<span class="keyword">int</span>*)<span class="built_in">realloc</span>(vfd-&gt;fd, (vfd-&gt;counter + <span class="number">5</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        vfd-&gt;max_counter += <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexof</span><span class="params">(VectorFd* vfd, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vfd-&gt;counter; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vfd-&gt;fd[i] == fd)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VectorFd* <span class="title">create_vector_fd</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VectorFd* vfd = (VectorFd*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(VectorFd));</span><br><span class="line">    vfd-&gt;fd = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>(<span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    vfd-&gt;counter = <span class="number">0</span>;</span><br><span class="line">    vfd-&gt;max_counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> vfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_vector_fd</span><span class="params">(VectorFd* vfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(vfd-&gt;fd);</span><br><span class="line">    <span class="built_in">free</span>(vfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_fd</span><span class="params">(VectorFd* vfd, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; vfd-&gt;counter - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vfd-&gt;fd[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_fd</span><span class="params">(VectorFd* vfd, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = indexof(vfd, fd);</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; vfd-&gt;counter - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        vfd-&gt;fd[i] = vfd-&gt;fd[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vfd-&gt;counter--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_fd</span><span class="params">(VectorFd* vfd, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    encapacity(vfd);</span><br><span class="line">    vfd-&gt;fd[vfd-&gt;counter++] = fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fcbtl-Function"><a href="#fcbtl-Function" class="headerlink" title="fcbtl Function"></a>fcbtl Function</h3><ul><li><p>Some common functions</p><ul><li><p><code>int fcntl(int fd, int cmd, ... /* arg */ );</code>: performs one of the operations described below on the open file descriptor <em>fd</em>. The operation is determined by <em>cmd</em>.</p><ul><li><p><strong>F_GETFL</strong>: Return (as the function result) the file access mode and the file status flags; <em>arg</em> is ignored.</p></li><li><p><strong>F_SETFL</strong>: Set the file status flags to the value specified by <em>arg</em>. File access mode (<strong>O_RDONLY</strong>, <strong>O_WRONLY</strong>, <strong>O_RDWR</strong>) and file creation flags (i.e., <strong>O_CREAT</strong>, <strong>O_EXCL</strong>, <strong>O_NOCTTY</strong>, <strong>O_TRUNC</strong>) in <em>arg</em> are ignored. On Linux, this command can change only the <strong>O_APPEND</strong>, <strong>O_ASYNC</strong>, <strong>O_DIRECT</strong>, <strong>O_NOATIME</strong>, and <strong>O_NONBLOCK</strong> flags. It is not possible to change the <strong>O_DSYNC</strong> and <strong>O_SYNC</strong> flags; see <strong>BUGS</strong>, below.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implememt I/O multiplexing with fcntl function</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">VectorFd* vfd;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_servive</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    <span class="keyword">size_t</span> size = read(fd, buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        remove_fd(vfd, fd);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        write(STDOUT_FILENO, buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">        <span class="keyword">if</span> (write(fd, buff, size) != (<span class="keyword">int</span>)size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EPIPE) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"write error\n"</span>);</span><br><span class="line">                remove_fd(vfd, fd);</span><br><span class="line">                close(fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGINT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server close\n"</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        destroy_vector_fd(vfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">th_fn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vfd-&gt;counter; i++) &#123;</span><br><span class="line">            do_servive(get_fd(vfd, i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_addr</span><span class="params">(struct sockaddr_in* client_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s(%d) connected!\n"</span>, inet_ntoa(client_addr-&gt;sin_addr), ntohs(client</span><br><span class="line">_addr-&gt;sin_port));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s [port]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    signal(SIGINT, sig_handler);</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    bind(sockfd, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    listen(sockfd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    vfd = create_vector_fd();</span><br><span class="line">    <span class="keyword">pthread_t</span> th;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    pthread_create(&amp;th, &amp;attr, th_fn, (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = accept(sockfd, (struct sockaddr*)&amp;client_addr, &amp;len);</span><br><span class="line">        out_addr(&amp;client_addr);</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        fcntl(fd, F_GETFL, &amp;val);</span><br><span class="line">        val |= O_NONBLOCK;</span><br><span class="line">        fcntl(fd, F_SETFL, val);</span><br><span class="line">        add_fd(vfd, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="select-Function"><a href="#select-Function" class="headerlink" title="select Function"></a>select Function</h3><ul><li><p>Some common functions</p><ul><li><p><code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code>: allow a program to monitor multiple file descriptors, waiting until one or more of the file descriptors become “ready” for some class of <strong>I/O</strong> operation (e.g., input possible). A file descriptor is considered ready if it is possible to perform a corresponding <strong>I/O</strong> operation (e.g., <u>read</u>() without blocking, or a sufficiently small <u>write</u>()). Four macros are provided to manipulate the sets.</p><ul><li><p><code>void FD_ZERO(fd_set *set);</code>: clear a set.</p></li><li><p><code>void FD_SET(int fd, fd_set *set);</code>: add a given file descriptor from a set.</p></li><li><p><code>void FD_CLR(int fd, fd_set *set);</code>: remove a given file descriptor from a set.</p></li><li><p><code>int FD_ISSET(int fd, fd_set *set);</code>: test to see if a file descriptor is part of the set</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implement I/O multiplexing with select function</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">VectorFd* vfd;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_servive</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    <span class="keyword">size_t</span> size = read(fd, buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        remove_fd(vfd, fd);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        write(STDOUT_FILENO, buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">        <span class="keyword">if</span> (write(fd, buff, size) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EPIPE) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"write error\n"</span>);</span><br><span class="line">                remove_fd(vfd, fd);</span><br><span class="line">                close(fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGINT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server close\n"</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        destroy_vector_fd(vfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_set</span><span class="params">(fd_set* <span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FD_ZERO(<span class="built_in">set</span>);</span><br><span class="line">    <span class="keyword">int</span> max_fd = vfd-&gt;fd[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vfd-&gt;counter; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = get_fd(vfd, i);</span><br><span class="line">        <span class="keyword">if</span> (fd &gt; max_fd)</span><br><span class="line">            max_fd = fd;</span><br><span class="line">        FD_SET(fd, <span class="built_in">set</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">th_fn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">t</span>;</span></span><br><span class="line">    t.tv_sec = <span class="number">2</span>;</span><br><span class="line">    t.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxfd;</span><br><span class="line">    fd_set <span class="built_in">set</span>;</span><br><span class="line">    maxfd = add_set(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((n = select(maxfd + <span class="number">1</span>, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;t)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vfd-&gt;counter; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> fd = get_fd(vfd, i);</span><br><span class="line">                <span class="keyword">if</span> (FD_ISSET(fd, &amp;<span class="built_in">set</span>))</span><br><span class="line">                    do_servive(fd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t.tv_sec = <span class="number">2</span>;</span><br><span class="line">        t.tv_usec = <span class="number">0</span>;</span><br><span class="line">        maxfd = add_set(&amp;<span class="built_in">set</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_addr</span><span class="params">(struct sockaddr_in* client_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s(%d) connected!\n"</span>, inet_ntoa(client_addr-&gt;sin_addr), ntohs(client_addr-&gt;sin_por</span><br><span class="line">t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: %s [port]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    signal(SIGINT, sig_handler);</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    bind(sockfd, (struct sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    listen(sockfd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    vfd = create_vector_fd();</span><br><span class="line">    <span class="keyword">pthread_t</span> th;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    pthread_create(&amp;th, &amp;attr, th_fn, (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = accept(sockfd, (struct sockaddr*)&amp;client_addr, &amp;len);</span><br><span class="line">        out_addr(&amp;client_addr);</span><br><span class="line">        add_fd(vfd, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C Language </tag>
            
            <tag> Internetwork Communication </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My Shell and Vim Editor</title>
      <link href="/2019/07/01/MyShellAndVim/"/>
      <url>/2019/07/01/MyShellAndVim/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Sharp tools make good work.</p></blockquote><h2 id="Vim-and-SpaceVim"><a href="#Vim-and-SpaceVim" class="headerlink" title="Vim and SpaceVim?"></a>Vim and SpaceVim?</h2><h3 id="What-is-Vim"><a href="#What-is-Vim" class="headerlink" title="What is Vim"></a>What is Vim</h3><p>&emsp;Vim is a powerful and full-screen text editor that is the most commonly used to edit on Linux for creating, editing, and displaying text files. </p><h3 id="What-is-Spacevim"><a href="#What-is-Spacevim" class="headerlink" title="What is Spacevim"></a>What is Spacevim</h3><p>&emsp;Now, we can replace it with SpaceVim. SpaceVim is a distribution of the Vim editor that’s inspired by spacemacs. It manages collections of plugins in layers, which help collecting related packages together to provide features. For example, the <code>lang#python</code> layer collects deoplete.nvim, neomake and jedi-vim together to provide autocompletion, syntax checking, and documentation lookup. This approach helps keeping configuration organized and reduces overhead for the user by keeping them from having to think about what packages to install.<br><a id="more"></a></p><h2 id="Vim-Shortcuts"><a href="#Vim-Shortcuts" class="headerlink" title="Vim Shortcuts"></a>Vim Shortcuts</h2><h3 id="NORMAL-mode"><a href="#NORMAL-mode" class="headerlink" title="NORMAL mode"></a>NORMAL mode</h3><ol><li><p>Insert command</p><ul><li><code>a</code>: insert after the character where the cursor is.</li><li><code>A</code>: insert at the end of the line where the cursor is.</li><li><code>i</code>: inserts before the character where the cursor is.</li><li><code>I</code>: insert at the beginning of the line where the cursor is.</li><li><code>o</code>: insert a new line below the cursor.</li><li><code>O</code>: inserts a new line above the cursor.</li></ul></li><li><p>Locate command</p><ul><li><code>0</code>: to the beginning of each line.</li><li><code>$</code>: to the end of each line.</li><li><code>gg</code>: to the first line.</li><li><code>G</code>: to the last line.</li><li><code>nG</code> or <code>:n</code>: to the n line.</li></ul></li><li><p>Delete command</p><ul><li><code>x</code>: deletes the character where the cursor is located.</li><li><code>dd</code>: deletes the cursor row.</li><li><code>D</code>: deletes the cursor to the end of the line.</li><li><code>n1,n2d</code>: deletes rows in the specified range.</li></ul></li><li><p>Copy and cut commands</p><ul><li><code>yy</code>: copy the current row.</li><li><code>dd</code>: cut the current row.</li><li><code>p</code>: paste below the current cursor line.</li><li><code>P</code>: paste above the current cursor line.</li></ul></li><li><p>Replace and undo commands</p><ul><li><code>r</code>: replaces the character where the cursor is.</li><li><code>R</code>: replace characters from where the cursor is, and press Esc to end.</li><li><code>u</code>: undo the previous step.</li><li><code>&lt;c-r&gt;</code>: resume the cancellation.</li></ul></li><li><p>Match command</p><ul><li><code>#/*</code>: match the word where the cursor is currently, move the cursor to the next (or previous) word to match the word.</li><li><code>%</code>: match bracket.</li></ul></li></ol><h3 id="INSERT-mode"><a href="#INSERT-mode" class="headerlink" title="INSERT mode"></a>INSERT mode</h3><ul><li>Similar to editing in most modern editors. In insert mode, buffers can be modified with the text inserted.</li></ul><h3 id="COMMAND-mode"><a href="#COMMAND-mode" class="headerlink" title="COMMAND mode"></a>COMMAND mode</h3><ol><li><p>Search command</p><ul><li><p><code>/string</code>: search for a specified string.</p><ul><li><p><code>n</code>: next string</p></li><li><p><code>N</code>: previous string</p></li></ul></li></ul></li></ol><ul><li><code>:%s/old/new/g</code>: Replaces the specified string within the full text scope.<ul><li><code>:n1,n2s/old/new/g</code>: Replaces the specified string within a range.</li></ul></li></ul><ol><li><p>Save and exit commands</p><ul><li><code>:wq!</code>: save the changes and exit(available for file owner and root).</li><li><code>:w filename</code>: save as the specified file. </li></ul></li><li><p>Import command</p><ul><li><code>:r !command</code>: import command execution results.</li><li><code>:ab A B</code>: replace A with B.</li><li><code>:map &lt;c-A~Z&gt; commands</code>: set shortcut keys.</li></ul></li></ol><h3 id="VISUAL-mode"><a href="#VISUAL-mode" class="headerlink" title="VISUAL mode"></a>VISUAL mode</h3><ol><li>Case change command<ul><li><code>gU</code>: change it to the capital.</li><li><code>gu</code>: change it to the lower.</li></ul></li></ol><h2 id="My-Configuration"><a href="#My-Configuration" class="headerlink" title="My Configuration"></a>My Configuration</h2><h3 id="SpaceVim-d-init-toml"><a href="#SpaceVim-d-init-toml" class="headerlink" title="~/.SpaceVim.d/init.toml"></a>~/.SpaceVim.d/init.toml</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#=============================================================================</span></span><br><span class="line"><span class="section"># dark_powered.toml --- dark powered configuration example for SpaceVim</span></span><br><span class="line"><span class="section"># Copyright (c) 2016-2017 Wang Shidong &amp; Contributors</span></span><br><span class="line"><span class="section"># Author: Wang Shidong &lt; wsdjeg at 163.com &gt;</span></span><br><span class="line"><span class="section"># URL: https://spacevim.org</span></span><br><span class="line"><span class="section"># License: GPLv3</span></span><br><span class="line"><span class="section">#=============================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="section"># All SpaceVim option below [option] section</span></span><br><span class="line">[options]</span><br><span class="line"><span class="code">    # set spacevim theme. by default colorscheme layer is not loaded,</span></span><br><span class="line"><span class="code">    # if you want to use more colorscheme, please load the colorscheme</span></span><br><span class="line"><span class="code">    # layer</span></span><br><span class="line"><span class="code">    colorscheme = "gruvbox"</span></span><br><span class="line"><span class="code">    colorscheme_bg = "dark"</span></span><br><span class="line"><span class="code">    # Disable guicolors in basic mode, many terminal do not support 24bit</span></span><br><span class="line"><span class="code">    # true colors</span></span><br><span class="line"><span class="code">    enable_guicolors = true</span></span><br><span class="line"><span class="code">    # Disable statusline separator, if you want to use other value, please</span></span><br><span class="line"><span class="code">    # install nerd fonts</span></span><br><span class="line"><span class="code">    statusline_separator = "arrow"</span></span><br><span class="line"><span class="code">    statusline_inactive_separator = "arrow"</span></span><br><span class="line"><span class="code">    buffer_index_type = 1</span></span><br><span class="line"><span class="code">    enable_tabline_filetype_icon = true</span></span><br><span class="line"><span class="code">    enable_statusline_mode = false</span></span><br><span class="line"><span class="code">    # enable_ycm=1</span></span><br><span class="line"><span class="code">    snippet_engine = "ultisnips"</span></span><br><span class="line"></span><br><span class="line"><span class="section"># Enable autocomplete layer</span></span><br><span class="line">[[layers]]</span><br><span class="line">name = 'autocomplete'</span><br><span class="line">auto-completion-return-key-behavior = "complete"</span><br><span class="line">auto-completion-tab-key-behavior = "smart"</span><br><span class="line"></span><br><span class="line">[[layers]]</span><br><span class="line">name = 'shell'</span><br><span class="line">default_position = 'top'</span><br><span class="line">default_height = 30</span><br><span class="line"></span><br><span class="line">[[layers]]</span><br><span class="line">  name = "lang#c"</span><br><span class="line"></span><br><span class="line">[[layers]]</span><br><span class="line">  name = "lang#python"</span><br><span class="line"></span><br><span class="line">[[layers]]</span><br><span class="line">  name = "format"</span><br><span class="line"></span><br><span class="line">[[layers]]</span><br><span class="line">  name = "debug"</span><br></pre></td></tr></table></figure><h3 id="SpaceVim-init-vim"><a href="#SpaceVim-init-vim" class="headerlink" title="~/.SpaceVim/init.vim"></a>~/.SpaceVim/init.vim</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">"=============================================================================</span><br><span class="line">" init.vim --- Entry file for neovim</span><br><span class="line">" Copyright (c) 2016-2019 Wang Shidong &amp; Contributors</span><br><span class="line">" Author: Wang Shidong &lt; wsdjeg at 163.com &gt;</span><br><span class="line">" URL: https://spacevim.org</span><br><span class="line">" License: GPLv3</span><br><span class="line">"=============================================================================</span><br><span class="line"></span><br><span class="line">" C/C++ language</span><br><span class="line">let g:ycm<span class="emphasis">_enable_</span>diagnostic_signs = 0</span><br><span class="line">let g:ycm<span class="emphasis">_use_</span>clang = 0</span><br><span class="line">let g:ycm<span class="emphasis">_use_</span>clangd = 1</span><br><span class="line"></span><br><span class="line">" CompleteParameter</span><br><span class="line">let g:complete<span class="emphasis">_parameter_</span>use<span class="emphasis">_ultisnips_</span>mapping = 1</span><br><span class="line">let g:complete<span class="emphasis">_parameter_</span>echo_signature = 1</span><br><span class="line">let g:complete<span class="emphasis">_parameter_</span>py<span class="emphasis">_remove_</span>default = 1</span><br><span class="line">let g:UltiSnipsExpandTrigger = '&lt;c-o&gt;'</span><br><span class="line">let g:UltiSnipsJumpForwardTrigger = '&lt;tab&gt;'</span><br><span class="line">let g:UltiSnipsJumpBackwardTrigger = '&lt;c-p&gt;'</span><br><span class="line">inoremap &lt;silent&gt;&lt;expr&gt; ( complete<span class="emphasis">_parameter#pre_</span>complete("()")</span><br><span class="line">smap &lt;c-j&gt; &lt;Plug&gt;(complete<span class="emphasis">_parameter#goto_</span>next_parameter)</span><br><span class="line">imap &lt;c-j&gt; &lt;Plug&gt;(complete<span class="emphasis">_parameter#goto_</span>next_parameter)</span><br><span class="line">smap &lt;c-k&gt; &lt;Plug&gt;(complete<span class="emphasis">_parameter#goto_</span>previous_parameter)</span><br><span class="line">imap &lt;c-k&gt; &lt;Plug&gt;(complete<span class="emphasis">_parameter#goto_</span>previous_parameter)&lt;Paste&gt;</span><br><span class="line"></span><br><span class="line">" Python language</span><br><span class="line">let g:python<span class="emphasis">_host_</span>prog = '/home/yihe/anaconda2/bin/python'</span><br><span class="line">let g:python3<span class="emphasis">_host_</span>prog = '/home/yihe/anaconda3/bin/python'</span><br><span class="line">let g:loaded<span class="emphasis">_python_</span>provider = 1</span><br><span class="line"></span><br><span class="line">" YCM setting</span><br><span class="line">let g:ycm<span class="emphasis">_global_</span>ycm<span class="emphasis">_extra_</span>conf = "~/.ycm<span class="emphasis">_extra_</span>conf.py"</span><br><span class="line">let g:ycm<span class="emphasis">_python_</span>interpreter_path = '/home/yihe/anaconda3/bin/python3'</span><br><span class="line">  let g:ycm<span class="emphasis">_semantic_</span>triggers =  &#123;</span><br><span class="line"><span class="code">           \ 'c,cpp,python,java,go,erlang,perl': ['re!\w&#123;2&#125;'],</span></span><br><span class="line"><span class="code">           \ 'cs,lua,javascript': ['re!\w&#123;2&#125;'],</span></span><br><span class="line"><span class="code">           \ &#125;</span></span><br><span class="line"></span><br><span class="line">"loading</span><br><span class="line">execute 'source' fnamemodify(expand('&lt;sfile&gt;'), ':h').'/config/main.vim'</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">autocmd BufWritePre,BufRead *.c :inoremap &lt;Enter&gt; &lt;c-r&gt;=BracketsEnter('&#125;')&lt;CR&gt;</span><br><span class="line">autocmd BufWritePre,BufRead *.cpp :inoremap &lt;Enter&gt; &lt;c-r&gt;=BracketsEnter('&#125;')&lt;CR&gt;</span><br><span class="line">autocmd BufWritePre,BufRead *.h :inoremap &lt;Enter&gt; &lt;c-r&gt;=BracketsEnter('&#125;')&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">function BracketsEnter(char)</span><br><span class="line"><span class="code">    if getline('.')[col('.')-1] == a:char</span></span><br><span class="line"><span class="code">        return "\&lt;Enter&gt;\&lt;Tab&gt;\&lt;Esc&gt;mpa\&lt;Enter&gt;\&lt;Esc&gt;`pa" </span></span><br><span class="line"><span class="code">    else</span></span><br><span class="line"><span class="code">        return "\&lt;Enter&gt;"</span></span><br><span class="line"><span class="code">    endif</span></span><br><span class="line">endf</span><br><span class="line"></span><br><span class="line">set tabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line"></span><br><span class="line">ab mymail 1581727244@qq.com </span><br><span class="line">ab mygmail huangyihe52647849@gmail.com </span><br><span class="line">ab myPhone 18752116785</span><br><span class="line">ab myQQ 1581727244</span><br><span class="line"></span><br><span class="line">" lua require('spacevim').bootstrap()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Common Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thread Management</title>
      <link href="/2019/04/07/ThreadManagement/"/>
      <url>/2019/04/07/ThreadManagement/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>All roads lead to Rome.</p></blockquote><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><h3 id="Concept-of-Thread"><a href="#Concept-of-Thread" class="headerlink" title="Concept of Thread"></a>Concept of Thread</h3><ol><li>A thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler. Multiple threads can exist within one process, executing concurrently and sharing resources such as memory, while different processes do not share these resources. In particular, the threads of a process share its executable code and the values of its dynamically allocated variables and non-thread-local global variables at any given time. In a word, the process is the basic unit of resource allocation and the thread is the basic unit of independent scheduling. <a id="more"></a></li><li>The implementation of threads can be divided into two types: user-level thread and kernel-level thread. In particular, the user-level threads are implemented by users to solve the context switch problem and the kernel is not aware of the existence of these threads. It handles them as if they were single-threaded processes. User-level threads are small and much faster than kernel level threads. They are represented by a program counter (<strong>PC</strong>), stack, registers and a small process control block. Also, there is no kernel involvement in synchronization for user-level threads. Kernel-level threads are handled by the operating system directly and the thread management is done by the kernel. The context information for the process as well as the process threads is all managed by the kernel. Because of this, kernel-level threads are slower than user-level threads.</li><li>Each thread within a process has its own unique identity, which is valid only in the process environment which it belongs to, and whose data type is <strong>pthread_t</strong>. The link library file needs to be used at compile time by <strong>-lpthread</strong> option.</li></ol><h3 id="Thread-vs-Process"><a href="#Thread-vs-Process" class="headerlink" title="Thread vs. Process"></a>Thread vs. Process</h3><ol><li><p>Threads differ from traditional multitasking operating system processes in several ways described below.</p><ul><li>Processes are typically independent, while threads exist as subsets of a process.</li><li>Processes carry considerably more state information than threads, whereas multiple threads within a process share process state as well as memory and other resources.</li><li>Processes have separate address spaces, whereas threads share their address space.</li><li>Processes interact only through system-provided inter-process communication mechanisms.</li><li>Context switching between threads in the same process is typically faster than context switching between processes.</li></ul></li><li>In a word, threads are used for small tasks, whereas processes are used for more ‘heavyweight’ tasks – basically the execution of applications. Another difference between a thread and a process is that threads within the same process share the same address space, whereas different processes do not.</li></ol><h3 id="Thread-Model"><a href="#Thread-Model" class="headerlink" title="Thread Model"></a>Thread Model</h3><ol><li><strong>1:1</strong> kernel-level threading: threads created by the user in a 1:1 correspondence with schedulable entities in the kernel are the simplest possible threading implementation. </li><li><strong>N:1</strong> (user-level threading): imply that all application-level threads map to one kernel-level scheduled entity; the kernel has no knowledge of the application threads. With this approach, context switching can be done very quickly and, in addition, it can be implemented even on simple kernels which do not support threading. One of the major drawbacks, however, is that it cannot benefit from the hardware acceleration on multi-threaded processors or multi-processor computers: there is never more than one thread being scheduled at the same time. For example: If one of the threads needs to execute an <strong>I/O</strong> request, the whole process is blocked and the threading advantage cannot be used. </li><li><strong>M:N</strong> (hybrid threading): map some M number of application threads onto some N number of kernel entities, or “virtual processors.” This is a compromise between kernel-level (“1:1”) and user-level (“N:1”) threading. In general, “M:N” threading systems are more complex to implement than either kernel or user threads, because changes to both kernel and user-space code are required. In the M:N implementation, the threading library is responsible for scheduling user threads on the available schedulable entities; this makes context switching of threads very fast, as it avoids system calls. However, this increases complexity and the likelihood of priority inversion, as well as suboptimal scheduling without extensive (and expensive) coordination between the userland scheduler and the kernel scheduler.</li></ol><h3 id="Thread-Creation"><a href="#Thread-Creation" class="headerlink" title="Thread Creation"></a>Thread Creation</h3><ol><li><p>A standardized interface for thread implementation is POSIX Threads (Pthreads), which is a set of C-function library calls. OS vendors are free to implement the interface as desired, but the application developer should be able to use the same interface across multiple platforms. Most Unix platforms including Linux support Pthreads. </p></li><li><p>Some common functions to creating threads</p><ul><li><p><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</code>: start a new thread in the calling process. The <em>attr</em> argument points to a <em>pthread_attr_t</em> structure whose contents are used at thread creation time to determine attributes for the new thread. Before returning, a successful call stores the ID of the new thread in the buffer pointed to by <em>thread</em>. The new thread starts execution by invoking <u>start_routine</u>(). <em>arg</em> is passed as the sole argument of <u>start_routine</u>(). On success, it returns 0; on error, it returns an error number, and the contents of <em>*thread</em> are undefined. </p></li><li><p><code>int pthread_equal(pthread_t t1, pthread_t t2);</code>: compare two thread identifiers. If the two thread IDs are equal, it returns a nonzero value; otherwise, it returns 0.</p></li><li><p><code>pthread_t pthread_self(void);</code>: return the ID of the calling thread. This is the same value that is returned in <strong>*thread</strong> in the <u>pthread_create</u>() call that created this thread. And this function always succeeds, returning the calling thread’s ID.</p></li><li><p><code>int pthread_join(pthread_t thread, void **retval);</code>: wait for the thread specified by <em>thread</em> to terminate. If that thread has already terminated, then <u>pthread_join</u>() returns immediately. The <em>thread</em> specified by <em>thread</em> must be joinable. If <em>retval</em> is not NULL, then <u>pthread_join</u>() copies the exit status of the target thread (i.e., the value that the target thread supplied to <u>pthread_exit</u>()) into the location pointed to by <em>retval</em>. On success, it returns 0; on error, it returns an error number.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implement the race between hare and tortoise</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="keyword">long</span> start;</span><br><span class="line">    <span class="keyword">long</span> end;</span><br><span class="line">&#125; RaceArg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">th_fn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RaceArg* r = (RaceArg*)arg;</span><br><span class="line">    <span class="keyword">long</span> i = r-&gt;start;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= r-&gt;end; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s(%lx) run %ld\n"</span>, r-&gt;name, pthread_self(), i);</span><br><span class="line">        usleep(r-&gt;time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)(r-&gt;end - r-&gt;start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> rabbit, turtle;</span><br><span class="line"></span><br><span class="line">    RaceArg r_a = &#123; <span class="string">"rabbit"</span>, (<span class="keyword">int</span>)(drand48() * <span class="number">1000000</span>), <span class="number">20</span>, <span class="number">50</span> &#125;;</span><br><span class="line">    RaceArg <span class="keyword">r_t</span> = &#123; <span class="string">"turtle"</span>, (<span class="keyword">int</span>)(drand48() * <span class="number">1000000</span>), <span class="number">10</span>, <span class="number">60</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_create(&amp;rabbit, <span class="literal">NULL</span>, th_fn, (<span class="keyword">void</span>*)&amp;r_a)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread_create error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_create(&amp;turtle, <span class="literal">NULL</span>, th_fn, (<span class="keyword">void</span>*)&amp;<span class="keyword">r_t</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread_create error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span>* distance;</span><br><span class="line"></span><br><span class="line">    pthread_join(rabbit, (<span class="keyword">void</span>**)&amp;distance);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"rabbit's distance is %ld\n"</span>, (<span class="keyword">long</span>)distance);</span><br><span class="line">    pthread_join(turtle, (<span class="keyword">void</span>**)&amp;distance);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"turtle's distance is %ld\n"</span>, (<span class="keyword">long</span>)distance);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"control thread id: %lx\n"</span>, pthread_self());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"finished!\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="Thread-Termination"><a href="#Thread-Termination" class="headerlink" title="Thread Termination"></a>Thread Termination</h3><ol><li><p>Active termination</p><ul><li>Call <strong>return</strong> statement</li><li>Call <code>pthread_exit()</code> function</li><li><code>void pthread_exit(void *retval);</code>: terminate the calling thread and returns a value via <strong>retval</strong> that (if the thread is joinable) is available to another thread in the same process that calls <code>pthread_join()</code>.</li></ul></li><li><p>Passive termination</p><ul><li>Other thread calls <code>pthread_cancel(pthid)</code> function to end it.</li><li><code>int pthread_cancel(pthread_t thread);</code>: send a cancellation request to the thread <em>thread</em>. Whether and when the target thread reacts to the cancellation request depends on two attributes that are under the control of that thread: its cancelability <em>state</em> and <em>type</em>. On success, it returns 0; on error, it returns a nonzero error number.</li></ul></li><li>Release of thread resources: Whether it’s active termination or passive termination, none of the threads automatically releases resources. But we can use the methods below, either call the <code>pthread_join()</code> function, or set the detach state of the thread to <strong>PTHREAD_CREATE_DETACHED</strong>.</li><li>Cleanup function of a thread<ul><li><code>void pthread_cleanup_push(void (*routine)(void *), void *arg);</code>: push <em>routine</em> onto the top of the stack of clean-up handlers. When <em>routine</em> is later invoked, it will be given <em>arg</em> as its argument.</li><li><code>void pthread_cleanup_pop(int execute);</code>: remove the <em>routine</em> at the top of the stack of clean-up handlers, and optionally executes it if execute is nonzero.</li></ul></li></ol><h3 id="Thread-Attribution"><a href="#Thread-Attribution" class="headerlink" title="Thread Attribution"></a>Thread Attribution</h3><ol><li><p>Some common attribution about thread</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Detach state        = PTHREAD_CREATE_JOINABLE/PTHREAD_CREATE_DETACHED</span><br><span class="line">Scope               = PTHREAD_SCOPE_SYSTEM</span><br><span class="line">Inherit scheduler   = PTHREAD_EXPLICIT_SCHED</span><br><span class="line">Scheduling policy   = SCHED_OTHER</span><br><span class="line">Scheduling priority = <span class="number">0</span></span><br><span class="line">Guard size          = <span class="number">0</span> bytes</span><br><span class="line">Stack address       = <span class="number">0x40197000</span></span><br><span class="line">Stack size          = <span class="number">0x3000000</span> bytes</span><br></pre></td></tr></table></figure></li><li><p>Some common function about thread attribution</p><ul><li><p><code>int pthread_attr_init(pthread_attr_t *attr);</code>: initialize the thread attributes object pointed to by <em>attr</em> with default attribute values. On success, it returns 0; on error, they return a nonzero error number.</p></li><li><p><code>int pthread_attr_destroy(pthread_attr_t *attr);</code>: used when a thread attributes object is no longer required. On success, it returns 0; on error, they return a nonzero error number.</p></li><li><p><code>int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);</code>: return the detach state attribute of the thread attributes object <em>attr</em> in the buffer pointed to by <em>detachstate</em>. On success, it returns 0; on error, they return a nonzero error number.</p></li><li><p><code>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code>: set the detach state attribute of the thread attributes object referred to by <em>attr</em> to the value specified in <em>detachstate</em>. On success, it returns 0; on error, they return a nonzero error number.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare the difference between pthread_join and modify detach state</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_state</span><span class="params">(<span class="keyword">pthread_attr_t</span>* attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">if</span> (pthread_attr_getdetachstate(attr, &amp;state) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"getdetachstate error\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state == PTHREAD_CREATE_JOINABLE) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"joinable state\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == PTHREAD_CREATE_DETACHED) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"detached state\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"error state\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">th_fn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= (<span class="keyword">long</span>)arg; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err, res;</span><br><span class="line">    <span class="keyword">pthread_t</span> default_th, detach_th;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    out_state(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_create(&amp;default_th, &amp;attr, th_fn, (<span class="keyword">void</span>*)<span class="number">100</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread create error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_join(default_th, (<span class="keyword">void</span>*)&amp;res)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, strerror(err));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"default return is %d\n"</span>, (<span class="keyword">int</span>)res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-----------------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    out_state(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_create(&amp;detach_th, &amp;attr, th_fn, (<span class="keyword">void</span>*)<span class="number">100</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread create error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_join(default_th, (<span class="keyword">void</span>*)&amp;res)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, strerror(err));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"default return is %d\n"</span>, (<span class="keyword">int</span>)res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ol><li><p>Thread and signal</p><ul><li><p>A process’s signal is shared by all its threads, and each thread has its own signal mask and pending word. For example, a timer is a process resource, and all threads in the process share the same timer.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the child thread calls alarm() to send alarm signal to the main thread by default</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pthread id in the sig_handler: %lx\n"</span>, pthread_self());</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGALRM) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"timeout...\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">th_fn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGALRM, sig_handler);</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"(%lx) i: %d\n"</span>, pthread_self(), i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> th;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;th, &amp;attr, th_fn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"control thread(%lx) is runing...\n"</span>, pthread_self());</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"control thread over\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>int pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);</code>: fetch and/or change the signal mask of the calling thread. The signal mask is the set of signals whose delivery is currently blocked for the caller. On success, it returns 0; on error, it returns an error number.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use pthread_sigmask to mask signal in the current thread</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pthread id in the sig_handler: %lx\n"</span>, pthread_self());</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGALRM) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"timeout...\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">th_fn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGALRM, sig_handler);</span><br><span class="line">    alarm(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"(%lx) i: %d\n"</span>, pthread_self(), i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> th;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;th, &amp;attr, th_fn, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGALRM);</span><br><span class="line">    pthread_sigmask(SIG_SETMASK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"control thread(%lx) is runing...\n"</span>, pthread_self());</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"control thread over\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Thread-Mutex"><a href="#Thread-Mutex" class="headerlink" title="Thread Mutex"></a>Thread Mutex</h2><h3 id="Concept-of-Thread-Mutex"><a href="#Concept-of-Thread-Mutex" class="headerlink" title="Concept of Thread Mutex"></a>Concept of Thread Mutex</h3><ol><li>Also known as direct constraint relationship, a lock or mutex (from mutual exclusion) is a synchronization mechanism for enforcing limits on access to a resource in an environment where there are many threads of execution. A lock is designed to enforce a mutual exclusion concurrency control policy. </li><li>Usually, three methods are used to solve it as below.<ul><li>the metux lock</li><li>the read-write lock</li><li>the thread semaphore</li></ul></li></ol><h3 id="Metux-Lock"><a href="#Metux-Lock" class="headerlink" title="Metux Lock"></a>Metux Lock</h3><ol><li>Concept of the metux lock: a simple locking method to control access to a shared resource. At the same time there is only one thread to master a mutex to the shared resource. If another thread wants to access the shared resources, it is suspended until the locked thread releases the mutex.</li><li><p>Initialization and destruction of a mutex lock</p><ul><li><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code>: shall initialize the mutex referenced by <em>mutex</em> with attributes specified by <em>attr</em>. If <em>attr</em> is NULL, the default mutex attributes are used.</li><li><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code>: shall destroy the mutex object referenced by <em>mutex</em>; the mutex object becomes, in effect, uninitialized. An implementation may cause it to set the object referenced by <em>mutex</em> to an invalid value.</li><li>If successful, they shall return zero; otherwise, an error number shall be returned to indicate the error.</li></ul></li><li><p>Lock and unlock of a mutex lock</p><ul><li><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code>: The mutex object referenced by <em>mutex</em> shall be locked by a call to <u>pthread_mutex_lock</u>(). If the mutex is already locked by another thread, the calling thread shall block until the mutex becomes available.</li><li><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code>: shall be equivalent to <u>pthread_mutex_lock</u>(), except that if the mutex object referenced by <em>mutex</em> is currently locked (by any thread, including the current thread), the call shall return immediately.</li><li><code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code>: shall release the mutex object referenced by <em>mutex</em>. The manner in which a mutex is released is dependent upon the mutex’s type attribute.</li><li>If successful, they shall return zero; otherwise, an error number shall be returned to indicate the error.</li></ul></li><li><p>Type attribute of a mutex lock</p><ul><li><p><code>int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict attr, int *restrict type);</code>: get the mutex type attribute.</p></li><li><p><code>int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);</code>: set the mutex type attribute.</p></li><li><p>Upon successful completion, the <u>pthread_mutexattr_gettype</u>() function shall return zero and store the value of the type attribute of attr into the object referenced by the type parameter. Otherwise, an error shall be returned to indicate the error. If successful, the <u>pthread_mutexattr_settype</u>() function shall return zero; otherwise, an error number shall be returned to indicate the error.</p></li><li><p>The type of mutex is contained in the type attribute of the mutex attributes. Valid mutex types include.</p><ul><li><p><strong>PTHREAD_MUTEX_NORMAL</strong>: lock successfully at first, but the thread to lock will block then.</p></li><li><p><strong>PTHREAD_MUTEX_ERRORCHECK</strong>: lock successfully at first, and lock successfully at second with counting inside.</p></li><li><p><strong>PTHREAD_MUTEX_RECURSIVE</strong>: lock successfully at first, then error occurs at second.</p></li><li><p><strong>PTHREAD_MUTEX_DEFAULT</strong>: be the same as <strong>PTHREAD_MUTEX_NORMAL</strong>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// three type of mutex attribute</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-usage:%s [error|normal|recursive]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> mutexattr;</span><br><span class="line">    pthread_mutexattr_init(&amp;mutexattr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"recursive"</span>)) &#123;</span><br><span class="line">        pthread_mutexattr_settype(&amp;mutexattr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"error"</span>)) &#123;</span><br><span class="line">        pthread_mutexattr_settype(&amp;mutexattr, PTHREAD_MUTEX_ERRORCHECK);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pthread_mutexattr_settype(&amp;mutexattr, PTHREAD_MUTEX_NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, &amp;mutexattr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_lock(&amp;mutex) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"lock failure\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"lock success\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_lock(&amp;mutex) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"lock failure\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"lock success\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_mutexattr_destroy(&amp;mutexattr);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="Read-write-Lock"><a href="#Read-write-Lock" class="headerlink" title="Read-write Lock"></a>Read-write Lock</h3><ol><li>Concept of the read-write lock: a special spin lock that divides visitors to a shared resource into readers and writers, who only have read access to the shared resource, and writers who need to write to the shared resource. Allows multiple readers to access shared resources simultaneously, the maximum possible number of readers being the actual logical <strong>CPU</strong> number. Writers are exclusive. A read-write lock can only have one writer or multiple readers at the same time.</li><li><p>Initialization and destruction of a read-write lock</p><ul><li><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code>: allocate any resources required to use the read-write lock referenced by <em>rwlock</em> and initializes the lock to an unlocked state with attributes referenced by <em>attr</em>.</li><li><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code>: destroy the read-write lock object referenced by <em>rwlock</em> and release any resources used by the lock.</li><li>If successful, they shall return zero; otherwise, an error number shall be returned to indicate the error.</li></ul></li><li><p>Lock and unlock of a read-write lock</p><ul><li><p><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code>: apply a read lock to the read-write lock referenced by <em>rwlock</em>.</p></li><li><p><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code>: apply a write lock to the read-write lock referenced by <em>rwlock</em>.</p></li><li><p><code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code>: release a lock held on the read-write lock object referenced by <em>rwlock</em>.</p></li><li><p>If successful, they shall return zero; otherwise, an error number shall be returned to indicate the error.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test read-write lock</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-usage:%s [r|w] [r|w]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"r"</span>, argv[<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_rwlock_rdlock(&amp;rwlock) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"first read lock failure\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"first read lock success\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"w"</span>, argv[<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_rwlock_wrlock(&amp;rwlock) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"first write lock failure\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"first write lock success\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"r"</span>, argv[<span class="number">2</span>])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_rwlock_rdlock(&amp;rwlock) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"second read lock failure\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"second read lock success\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="string">"w"</span>, argv[<span class="number">2</span>])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_rwlock_wrlock(&amp;rwlock) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"second write lock failure\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"second write lock success\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">    pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Thread-synchronization"><a href="#Thread-synchronization" class="headerlink" title="Thread synchronization"></a>Thread synchronization</h2><h3 id="Concept-of-Thread-Synchronization"><a href="#Concept-of-Thread-Synchronization" class="headerlink" title="Concept of Thread Synchronization"></a>Concept of Thread Synchronization</h3><ol><li>Thread synchronization is defined as a mechanism which ensures that two or more concurrent processes or threads do not simultaneously execute some particular program segment known as critical section. Processes’ access to critical section is controlled by using synchronization techniques. When one thread starts executing the critical section (serialized segment of the program) the other thread should wait until the first thread finishes. If proper synchronization techniques are not applied, it may cause a race condition where the values of variables may be unpredictable and vary depending on the timings of context switches of the processes or threads.</li><li>For example, suppose that there are three processes, namely 1, 2, and 3. All three of them are concurrently executing, and they need to share a common resource (critical section) as shown in Figure 1. Synchronization should be used here to avoid any conflicts for accessing this shared resource. Hence, when Process 1 and 2 both try to access that resource, it should be assigned to only one process at a time. If it is assigned to Process 1, the other process (Process 2) needs to wait until Process 1 frees that resource</li><li>Another synchronization requirement which needs to be considered is the order in which particular processes or threads should be executed. Other than mutual exclusion, synchronization also deals with the following.<ul><li>Deadlock, which occurs when many processes are waiting for a shared resource (critical section) which is being held by some other process. In this case, the processes just keep waiting and execute no further;</li><li>Starvation, which occurs when a process is waiting to enter the critical section, but other processes monopolize the critical section, and the first process is forced to wait indefinitely;</li><li>Priority inversion, which occurs when a high-priority process is in the critical section, and it is interrupted by a medium-priority process. This violation of priority rules can happen under certain circumstances and may lead to serious consequences in real-time systems;</li><li>Busy waiting, which occurs when a process frequently polls to determine if it has access to a critical section. This frequent polling robs processing time from other processes.</li></ul></li><li>Usually, three methods are used to solve it as below:<ul><li>the condition variables</li><li>the thread semaphore</li></ul></li></ol><h3 id="Condition-Variable"><a href="#Condition-Variable" class="headerlink" title="Condition Variable"></a>Condition Variable</h3><ol><li><p>Concept of the condition variables: a mechanism to synchronize by using the shared global variable between threads. It mainly includes two actions: a thread waiting for condition variable’s condition to be true and hangs at the same time; Another thread makes the condition true. To prevent contention, the use of condition variables is always combined with a mutex lock.</p></li><li><p>Initialization and destruction of a condition variable:</p><ul><li><code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code>: initialize the condition variable referenced by <em>cond</em> with attributes referenced by <em>attr</em>.</li><li><code>int pthread_cond_destroy(pthread_cond_t *cond);</code>: destroy the given condition variable specified by <em>cond</em>; the object becomes, in effect, uninitialized.</li><li>If successful, they shall return zero; otherwise, an error number shall be returned to indicate the error.</li></ul></li><li><p>Wait function of a condition variable:</p><ul><li><code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code>: block on a condition variable. The application shall ensure that these functions are called with <em>mutex</em> locked by the calling thread; otherwise, an error or undefined behavior results.</li><li><code>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</code>: block on a condition variable, except that an error is returned if the absolute time specified by <em>abstime</em> passes (that is, system time equals or exceeds <em>abstime</em>) before the condition <em>cond</em> is signaled or broadcasted, or if the absolute time specified by <em>abstime</em> has already been passed at the time of the call.</li><li>Upon successful completion, a value of zero shall be returned; otherwise, an error number shall be returned to indicate the error.</li></ul></li><li><p>Signal function of a condition variable:</p><ul><li><p><code>int pthread_cond_signal(pthread_cond_t *cond);</code>: unblock at least one of the threads that are blocked on the specified condition variable <em>cond</em> (if any threads are blocked on <em>cond</em>).</p></li><li><p><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code>: unblock all threads currently blocked on the specified condition variable <em>cond</em>.</p></li><li><p>If successful, they shall return zero; otherwise, an error number shall be returned to indicate the error.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test condition variable</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">int</span> counter;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">&#125; Result;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">set_fn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    Result* r = (Result*)arg;</span><br><span class="line">    r-&gt;res = sum;</span><br><span class="line">    pthread_mutex_lock(&amp;r-&gt;mutex);</span><br><span class="line">    <span class="keyword">while</span> (r-&gt;counter &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;r-&gt;mutex);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">        pthread_mutex_lock(&amp;r-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;r-&gt;mutex);</span><br><span class="line">    pthread_cond_broadcast(&amp;r-&gt;cond);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">get_fn</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Result* r = (Result*)arg;</span><br><span class="line">    pthread_mutex_lock(&amp;r-&gt;mutex);</span><br><span class="line">    r-&gt;counter++;</span><br><span class="line"></span><br><span class="line">    pthread_cond_wait(&amp;r-&gt;cond, &amp;r-&gt;mutex);</span><br><span class="line">    pthread_mutex_unlock(&amp;r-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = r-&gt;res;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0x%lx get sum is %d\n"</span>, pthread_self(), res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> cal, get1, get2;</span><br><span class="line"></span><br><span class="line">    Result r;</span><br><span class="line">    r.counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pthread_cond_init(&amp;r.cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;r.mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_create(&amp;get1, <span class="literal">NULL</span>, get_fn, (<span class="keyword">void</span>*)&amp;r)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread create error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_create(&amp;get2, <span class="literal">NULL</span>, get_fn, (<span class="keyword">void</span>*)&amp;r)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread create error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((err = pthread_create(&amp;cal, <span class="literal">NULL</span>, set_fn, (<span class="keyword">void</span>*)&amp;r)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread create error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(get1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(get2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cal, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_cond_destroy(&amp;r.cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;r.mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Reader and writer question</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// one reader and one writer</span></span><br><span class="line">   </span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">       <span class="keyword">int</span> value;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">pthread_cond_t</span> rc;</span><br><span class="line">       <span class="keyword">pthread_mutex_t</span> rm;</span><br><span class="line">       <span class="keyword">int</span> r_wait;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">pthread_cond_t</span> wc;</span><br><span class="line">       <span class="keyword">pthread_mutex_t</span> wm;</span><br><span class="line">       <span class="keyword">int</span> w_wait;</span><br><span class="line">   </span><br><span class="line">   &#125; Storage;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">set_data</span><span class="params">(Storage* p, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       p-&gt;value = value;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">get_data</span><span class="params">(Storage* p)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> p-&gt;value;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span>* <span class="title">set_th</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       Storage* p = (Storage*)arg;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">           set_data(p, i);</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"0x%lx write data: %d\n"</span>, pthread_self(), i);</span><br><span class="line">           pthread_mutex_lock(&amp;p-&gt;rm);</span><br><span class="line">           <span class="keyword">while</span> (!p-&gt;r_wait) &#123;</span><br><span class="line">               pthread_mutex_unlock(&amp;p-&gt;rm);</span><br><span class="line">               sleep(<span class="number">1</span>);</span><br><span class="line">               pthread_mutex_lock(&amp;p-&gt;rm);</span><br><span class="line">           &#125;</span><br><span class="line">           p-&gt;r_wait = <span class="number">0</span>;</span><br><span class="line">           pthread_mutex_unlock(&amp;p-&gt;rm);</span><br><span class="line">           pthread_cond_broadcast(&amp;p-&gt;rc);</span><br><span class="line">   </span><br><span class="line">           pthread_mutex_lock(&amp;p-&gt;wm);</span><br><span class="line">           p-&gt;w_wait = <span class="number">1</span>;</span><br><span class="line">           pthread_cond_wait(&amp;p-&gt;wc, &amp;p-&gt;wm);</span><br><span class="line">           pthread_mutex_unlock(&amp;p-&gt;wm);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span>* <span class="title">get_th</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       Storage* p = (Storage*)arg;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">           pthread_mutex_lock(&amp;p-&gt;rm);</span><br><span class="line">           p-&gt;r_wait = <span class="number">1</span>;</span><br><span class="line">           pthread_cond_wait(&amp;p-&gt;rc, &amp;p-&gt;rm);</span><br><span class="line">           pthread_mutex_unlock(&amp;p-&gt;rm);</span><br><span class="line">           <span class="keyword">int</span> value = get_data(p);</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"0x%lx read data: %d\n"</span>, pthread_self(), value);</span><br><span class="line">   </span><br><span class="line">           pthread_mutex_lock(&amp;p-&gt;wm);</span><br><span class="line">           <span class="keyword">while</span> (!p-&gt;w_wait) &#123;</span><br><span class="line">               pthread_mutex_unlock(&amp;p-&gt;wm);</span><br><span class="line">               sleep(<span class="number">1</span>);</span><br><span class="line">               pthread_mutex_lock(&amp;p-&gt;wm);</span><br><span class="line">           &#125;</span><br><span class="line">           p-&gt;w_wait = <span class="number">0</span>;</span><br><span class="line">           pthread_mutex_unlock(&amp;p-&gt;wm);</span><br><span class="line">           pthread_cond_broadcast(&amp;p-&gt;wc);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> err;</span><br><span class="line">       <span class="keyword">pthread_t</span> rth, wth;</span><br><span class="line">   </span><br><span class="line">       Storage s;</span><br><span class="line">       <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">       pthread_mutex_init(&amp;s.rm, <span class="literal">NULL</span>);</span><br><span class="line">       pthread_mutex_init(&amp;s.wm, <span class="literal">NULL</span>);</span><br><span class="line">       pthread_cond_init(&amp;s.rc, <span class="literal">NULL</span>);</span><br><span class="line">       pthread_cond_init(&amp;s.wc, <span class="literal">NULL</span>);</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">if</span> ((err = pthread_create(&amp;rth, <span class="literal">NULL</span>, get_th, (<span class="keyword">void</span>*)&amp;s)) != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"thread create error\n"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((err = pthread_create(&amp;wth, <span class="literal">NULL</span>, set_th, (<span class="keyword">void</span>*)&amp;s)) != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"thread create error\n"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       pthread_join(rth, <span class="literal">NULL</span>);</span><br><span class="line">       pthread_join(wth, <span class="literal">NULL</span>);</span><br><span class="line">   </span><br><span class="line">       pthread_mutex_destroy(&amp;s.rm);</span><br><span class="line">       pthread_mutex_destroy(&amp;s.wm);</span><br><span class="line">       pthread_cond_destroy(&amp;s.rc);</span><br><span class="line">       pthread_cond_destroy(&amp;s.wc);</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Thread-Semaphore"><a href="#Thread-Semaphore" class="headerlink" title="Thread Semaphore"></a>Thread Semaphore</h2><h3 id="Concept-of-Thread-Semaphore"><a href="#Concept-of-Thread-Semaphore" class="headerlink" title="Concept of Thread Semaphore"></a>Concept of Thread Semaphore</h3><ol><li>A non-negative integer (number of the shared resources) that will be subtracts by all threads/processes getting it, and when the integer value is zero, all threads trying to apply it will be in a waiting state. Usually, we define two operations on it: wait and post. When a thread calls wait, it either gets the resource and subtracts the semaphore by one or waits until the semaphore is greater than or equal to one. Post is actually doing the addition on the semaphore.</li><li>Semaphores are a useful tool in the prevention of race conditions; however, their use is by no means a guarantee that a program is free from these problems. Semaphores which allow an arbitrary resource count are called counting semaphores, while semaphores which are restricted to the values 0 and 1 (or locked/unlocked, unavailable/available) are called binary semaphores and are used to implement locks.</li></ol><h3 id="Usage-of-Thread-Semaphore"><a href="#Usage-of-Thread-Semaphore" class="headerlink" title="Usage of Thread Semaphore"></a>Usage of Thread Semaphore</h3><ol><li>Initialization and destruction of a thread semaphore:<ul><li><code>int sem_init(sem_t *sem, int pshared, unsigned int value);</code>: initializes the unnamed semaphore at the address pointed to by <em>sem</em>. The <em>value</em> argument specifies the initial value for the semaphore. The <em>pshared</em> argument indicates whether this semaphore is to be shared between the threads of a process, or between processes.</li><li><code>int sem_destroy(sem_t *sem);</code>: destroys the unnamed semaphore at the address pointed to by <em>sem</em>.</li><li>They returns 0 on success; on error, -1 is returned, and <em>errno</em> is set to indicate the error.</li></ul></li><li>Addition and subtraction of a thread semaphore<ul><li><code>int sem_post(sem_t *sem);</code>: increments (unlocks) the semaphore pointed to by <em>sem</em>. If the semaphore’s value consequently becomes greater than zero, then another process or thread blocked in a <u>sem_wait</u>() call will be woken up and proceed to lock the semaphore.</li><li><code>int sem_wait(sem_t *sem);</code>: decrements (locks) the semaphore pointed to by <em>sem</em>. If the semaphore’s value is greater than zero, then the decrement proceeds, and the function returns, immediately. If the semaphore currently has the value zero, then the call blocks until either it becomes possible to perform the decrement (i.e., the semaphore value rises above zero), or a signal handler interrupts the call.</li><li><code>int sem_trywait(sem_t *sem);</code>: the same as <u>sem_wait</u>(), except that if the decrement cannot be immediately performed, then call returns an error instead of blocking.</li><li>They return 0 on success; on error, the value of the semaphore is left unchanged, -1 is returned, and errno is set to indicate the error.</li></ul></li><li>Use the semaphore to implement the thread synchronization and mutex<ul><li>Mutex: set semaphore initial value is a positive integer</li><li>Synchronization: set semaphore initial value is zero </li></ul></li></ol><h3 id="Deadlock"><a href="#Deadlock" class="headerlink" title="Deadlock"></a>Deadlock</h3><ol><li><p>Concept of deadlock: it occurs when a process or thread enters a waiting state because a requested system resource is held by another waiting process, which in turn is waiting for another resource held by another waiting process. If a process is unable to change its state indefinitely because the resources requested by it are being used by another waiting process, then the system is said to be in a deadlock.</p></li><li><p>Necessary condition that deadlock occur</p><ul><li>Mutual exclusion: At least one resource must be held in a non-shareable mode. Otherwise, the processes would not be prevented from using the resource when necessary. Only one process can use the resource at any given instant of time.</li><li>No preemption: a resource can be released only voluntarily by the process holding it.</li><li><em>Hold and wait</em> or <em>resource holding:</em> a process is currently holding at least one resource and requesting additional resources which are being held by other processes.</li><li>Circular waiting: each process must be waiting for a resource which is being held by another process, which in turn is waiting for the first process to release the resource. In general, there is a set of waiting processes, $P= { P_1,P_2,…,P_n }$ such that $P_1$ is waiting for a resource held by $P_2$, $P_2$ is waiting for a resource held by $P_3$ and so on until $P_n$ is waiting for a resource held by $P_1$.</li></ul></li><li><p>Deadlock handling</p><ul><li>Ignoring deadlock: In this approach, it is assumed that a deadlock will never occur. This is also an application of the Ostrich algorithm. This approach was initially used by <strong>MINIX</strong> and <strong>UNIX</strong>. This is used when the time intervals between occurrences of deadlocks are large and the data loss incurred each time is tolerable.</li><li>Detection: Under the deadlock detection, deadlocks are allowed to occur. Then the state of the system is examined to detect that a deadlock has occurred and subsequently it is corrected. An algorithm is employed that tracks resource allocation and process states, it rolls back and restarts one or more of the processes in order to remove the detected deadlock. Detecting a deadlock that has already occurred is easily possible since the resources that each process has locked and/or currently requested are known to the resource scheduler of the operating system.<ul><li><em>Process termination:</em> one or more processes involved in the deadlock may be aborted. One could choose to abort all competing processes involved in the deadlock. This ensures that deadlock is resolved with certainty and speed. But the expense is high as partial computations will be lost. Or, one could choose to abort one process at a time until the deadlock is resolved. This approach has high overhead because after each abort an algorithm must determine whether the system is still in deadlock.[<em>citation needed</em>] Several factors must be considered while choosing a candidate for termination, such as priority and age of the process.</li><li><em>Resource preemption:</em> resources allocated to various processes may be successively preempted and allocated to other processes until the deadlock is broken.</li></ul></li><li>Prevention: deadlock prevention works by preventing one of the four Coffman conditions from occurring.<ul><li>Removing the mutual exclusion condition means that no process will have exclusive access to a resource. This proves impossible for resources that cannot be spooled. But even with spooled resources, deadlock could still occur. Algorithms that avoid mutual exclusion are called non-blocking synchronization algorithms.</li><li>The <em>hold and wait</em> or resource holding conditions may be removed by requiring processes to request all the resources they will need before starting up (or before embarking upon a particular set of operations). This advance knowledge is frequently difficult to satisfy and, in any case, is an inefficient use of resources. Another way is to require processes to request resources only when it has none. Thus, first they must release all their currently held resources before requesting all the resources they will need from scratch. This too is often impractical. It is so because resources may be allocated and remain unused for long periods. Also, a process requiring a popular resource may have to wait indefinitely, as such a resource may always be allocated to some process, resulting in resource starvation. (These algorithms, such as serializing tokens, are known as the all-or-none algorithms.)</li><li>The no preemption condition may also be difficult or impossible to avoid as a process has to be able to have a resource for a certain amount of time, or the processing outcome may be inconsistent or thrashing may occur. However, inability to enforce preemption may interfere with a <em>priority</em> algorithm. Preemption of a “locked out” resource generally implies a rollback, and is to be avoided, since it is very costly in overhead. Algorithms that allow preemption include lock-free and wait-free algorithms and optimistic concurrency control. If a process holding some resources and requests for some another resource(s) that cannot be immediately allocated to it, the condition may be removed by releasing all the currently being held resources of that process.</li><li>The final condition is the circular wait condition. Approaches that avoid circular waits include disabling interrupts during critical sections and using a hierarchy to determine a partial ordering of resources. If no obvious hierarchy exists, even the memory address of resources has been used to determine ordering and resources are requested in the increasing order of the enumeration. <strong>Banker algorithm</strong> can also be used.</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ultimate Knowledge </tag>
            
            <tag> OS System </tag>
            
            <tag> C Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POSIX Signal</title>
      <link href="/2019/03/07/PosixSignal/"/>
      <url>/2019/03/07/PosixSignal/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>While there is life there is hope.</p></blockquote><h2 id="What-is-Signal"><a href="#What-is-Signal" class="headerlink" title="What is Signal"></a>What is Signal</h2><h3 id="Concept-of-Signal"><a href="#Concept-of-Signal" class="headerlink" title="Concept of Signal"></a>Concept of Signal</h3><ol><li>Signals are a limited form of inter-process communication (<strong>IPC</strong>), typically used in Unix, Unix-like, and other POSIX-compliant operating systems. A signal is an asynchronous notification sent to a process or to a specific thread within the same process in order to notify it of an event that occurred. </li><li><p>Signals are similar to interrupts, the difference being that interrupts are mediated by the processor and handled by the kernel while signals are mediated by the kernel (possibly via system calls) and handled by processes. The kernel may pass an interrupt as a signal to the process that caused it (typical examples are <strong>SIGSEGV</strong>, <strong>SIGBUS</strong>, <strong>SIGILL</strong> and <strong>SIGFPE</strong>).</p><a id="more"></a><h3 id="Sending-Signals"><a href="#Sending-Signals" class="headerlink" title="Sending Signals"></a>Sending Signals</h3></li><li><p>Source that signal occurs</p><ul><li>Hardware: caused by a hardware driver, such as pressing a keyboard or other hardware failure.</li><li>Software: some common system function, like <code>kill()</code>, <code>raise()</code>, <code>alarm()</code>, <code>setitimer()</code> and so on. It also includes illegal operations and software setting (like gdb debug). Anyway, it is caused by kernel.</li></ul></li><li><p>The <code>kill()</code> system call sends a specified signal to a specified process, if permissions allow. Similarly, the <code>kill()</code> command allows a user to send signals to processes. The <code>raise()</code> library function sends the specified signal to the current process. And we can use <code>kill -l</code> on Linux to see some common signal.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGHUP1<span class="comment">/* Hangup.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGINT2<span class="comment">/* Interactive attention signal.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGQUIT3<span class="comment">/* Quit.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGILL4<span class="comment">/* Illegal instruction.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGTRAP5<span class="comment">/* Trace/breakpoint trap.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGABRT6<span class="comment">/* Abnormal termination.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGBUS7<span class="comment">/* Bus error.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGFPE8<span class="comment">/* Erroneous arithmetic operation.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGKILL9<span class="comment">/* Killed.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGUSR110<span class="comment">/* User-defined signal 1.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGSEGV11<span class="comment">/* Invalid access to storage.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGUSR212<span class="comment">/* User-defined signal 2.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGPIPE13<span class="comment">/* Broken pipe.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGALRM14<span class="comment">/* Alarm clock.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGTERM15<span class="comment">/* Termination request.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGSTKFLT16<span class="comment">/* Stack fault (obsolete).  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGCHLD17<span class="comment">/* Child terminated or stopped.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGCONT18<span class="comment">/* Continue.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGSTOP19<span class="comment">/* Stop, unblockable.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGTSTP20<span class="comment">/* Keyboard stop.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGTTIN21<span class="comment">/* Background read from control terminal.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGTTOU22<span class="comment">/* Background write to control terminal.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGURG23<span class="comment">/* Urgent data is available at a socket.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGXCPU24<span class="comment">/* CPU time limit exceeded.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGXFSZ25<span class="comment">/* File size limit exceeded.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGVTALRM26<span class="comment">/* Virtual timer expired.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGPROF27<span class="comment">/* Profiling timer expired.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGWINCH28<span class="comment">/* Window size change (4.3 BSD, Sun).  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGPOLL29<span class="comment">/* Pollable event occurred (System V).  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGPWR30<span class="comment">/* Power failure imminent.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SIGSYS31<span class="comment">/* Bad system call.  */</span></span></span><br></pre></td></tr></table></figure></li><li><p>Exceptions such as division by zero or a segmentation violation will generate signals (here, <strong>SIGFPE</strong> “floating point exception” and <strong>SIGSEGV</strong> “segmentation violation” respectively, which both by default cause a core dump and a program exit).The kernel can generate signals to notify processes of events. For example, <strong>SIGPIPE</strong> will be generated when a process writes to a pipe which has been closed by the reader; by default, this causes the process to terminate, which is convenient when constructing shell pipelines. Typing certain key combinations at the controlling terminal of a running process causes the system to send it certain signals. These default key combinations with modern operating systems can be changed with the stty command.</p><ul><li><strong>Ctrl-C</strong>: send an <strong>INT</strong> signal (“interrupt”, <strong>SIGINT</strong>); by default, this causes the process to terminate.</li><li><strong>Ctrl-Z</strong>: send a <strong>TSTP</strong> signal (“terminal stop”, <strong>SIGTSTP</strong>); by default, this causes the process to suspend execution.</li><li><strong>Ctrl-\</strong>: send a <strong>QUIT</strong> signal (<strong>SIGQUIT</strong>); by default, this causes the process to terminate and dump core.</li><li><strong>Ctrl-T</strong>: send an <strong>INFO</strong> signal (<strong>SIGINFO</strong>); by default, and if supported by the command, this causes the operating system to show information about the running command.</li></ul></li></ol><h2 id="Signal-Handing"><a href="#Signal-Handing" class="headerlink" title="Signal Handing"></a>Signal Handing</h2><h3 id="Three-Condition-to-Handle-Signals"><a href="#Three-Condition-to-Handle-Signals" class="headerlink" title="Three Condition to Handle Signals"></a>Three Condition to Handle Signals</h3><ol><li><p>Signal handlers can be installed with the <code>signal()</code> or <code>sigaction()</code> system call. If a signal handler is not installed for a particular signal, the default handler is used. Otherwise the signal is intercepted and the signal handler is invoked. The process can also specify two default behaviors, without creating a handler: ignore the signal (<strong>SIG_IGN</strong>) and use the default signal handler (<strong>SIG_DFL</strong>). There are two signals which cannot be intercepted and handled: <strong>SIGKILL</strong> and <strong>SIGSTOP</strong>.</p></li><li><p>Not every process can send signal to other process, except for kernel and super user. Usually, common process only send signal to the process with the same <strong>uid</strong> and <strong>gid</strong>.</p></li><li><p>Some common function about signal</p><ul><li><p><code>void (*signal(int sig, void (*func)(int)))(int);</code> or <code>sighandler_t signal(int signum, sighandler_t handler);</code>: chooses one of three ways in which receipt of the signal number <em>sig</em> is to be subsequently handled. If the value of <em>func</em> is <strong>SIG_DFL</strong>, default handling for that signal shall occur. If the value of <em>func</em> is <strong>SIG_IGN</strong>, the signal shall be ignored. Otherwise, the application shall ensure that <em>func</em> points to a function to be called when that signal occurs. An invocation of such a function because of a signal, or (recursively) of any further functions called by that invocation (other than functions in the standard library), is called a “signal handler’’. If the request can be honored, it shall return the value of <em>func</em> for the most recent call to <u>signal</u>() for the specified signal <em>sig</em>. Otherwise, <strong>SIG_ERR</strong> shall be returned and a positive value shall be stored in <em>errno</em>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test different signal</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pid:%d, signo:%d\n"</span>, getpid(), signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGTSTP, sig_handler) == SIG_ERR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"signal error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, SIGIGN) == SIG_ERR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"signal error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"test...\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>int raise(int sig);</code>: sends a signal to the calling process or thread. In a single-threaded program it is equivalent to <u>kill</u>(getpid(), sig). In a multi-threaded program it is equivalent to <u>pthread_kill</u>(pthread_self(), sig). It returns 0 on success, and nonzero for failure.</p></li><li><p><code>int kill(pid_t pid, int sig);</code>: send a signal to a process or a group of processes specified by <em>pid</em>. The signal to be sent is specified by <em>sig</em> and is either one from the list given in <u><signal.h></signal.h></u> or 0. If <em>pid</em> is greater than 0, <em>sig</em> shall be sent to the process whose process ID is equal to <em>pid</em>. If <em>pid</em> is 0, <em>sig</em> shall be sent to all processes (excluding an unspecified set of system processes) whose process group ID is equal to the process group ID of the sender, and for which the process has permission to send a signal. If <em>pid</em> is −1, <em>sig</em> shall be sent to all processes (excluding an unspecified set of system processes) for which the process has permission to send that signal. If <em>pid</em> is negative, but not −1, <em>sig</em> shall be sent to all processes (excluding an unspecified set of system processes) whose process group ID is equal to the absolute value of <em>pid</em>, and for which the process has permission to send a signal. Upon successful completion, 0 shall be returned. Otherwise, −1 shall be returned and <em>errno</em> set to indicate the error.</p></li></ul></li></ol><h2 id="Some-Applications-about-Signal"><a href="#Some-Applications-about-Signal" class="headerlink" title="Some Applications about Signal"></a>Some Applications about Signal</h2><h3 id="SIGCHLD-Signal"><a href="#SIGCHLD-Signal" class="headerlink" title="SIGCHLD Signal"></a>SIGCHLD Signal</h3><ol><li><p>The <strong>SIGCHLD</strong> signal is sent to a process when a child process terminates, is interrupted, or resumes after being interrupted. One common usage of the signal is to instruct the operating system to clean up the resources used by a child process after its termination without an explicit call to the <code>wait()</code> system call.</p></li><li><p>Usually, we use <strong>SIGCHLD</strong> signal to avoid defunct process in an asynchronous way rather than use <code>wait()</code> system function in a block way.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// avoid defunct process</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child process(%d) send %d\n"</span>, getpid(), signo);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGCHLD, sig_handler) == SIG_ERR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"signal error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'm child process\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I'm parent process\n"</span>);</span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="SIGALRM-SIGVTALRM-and-SIGPROF-Signal"><a href="#SIGALRM-SIGVTALRM-and-SIGPROF-Signal" class="headerlink" title="SIGALRM, SIGVTALRM and SIGPROF Signal"></a>SIGALRM, SIGVTALRM and SIGPROF Signal</h3><ol><li><p>The <strong>SIGALRM</strong> signal is sent to a process when the time limit specified in a call to a preceding alarm setting function (such as <code>setitimer()</code>) elapses. <strong>SIGALRM</strong> is sent when real or clock time elapses. <strong>SIGVTALRM</strong> is sent when <strong>CPU</strong> time used by the process elapses. <strong>SIGPROF</strong> is sent when <strong>CPU</strong> time used by the process and by the system on behalf of the process elapses.</p></li><li><p><code>unsigned int alarm(unsigned int seconds);</code>: arranges for a <strong>SIGALRM</strong> signal to be delivered to the calling process in <em>seconds</em> seconds. If <em>seconds</em> is zero, any pending alarm is canceled. It returns the number of seconds remaining until any previously scheduled alarm was due to be delivered, or zero if there was no previously scheduled alarm. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implement a timer </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signo == SIGALRM) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"clock time out\n"</span>);</span><br><span class="line">        alarm(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGALRM, sig_handler) == SIG_ERR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"signal sigalrm error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"test\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ultimate Knowledge </tag>
            
            <tag> OS System </tag>
            
            <tag> C Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Process Management</title>
      <link href="/2019/01/07/ProcessManagement/"/>
      <url>/2019/01/07/ProcessManagement/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>When we start with a positive attitude and view themselves as successful when we start a success.</p></blockquote><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><h3 id="Concept-of-Process"><a href="#Concept-of-Process" class="headerlink" title="Concept of Process"></a>Concept of Process</h3><ol><li>a process is the instance of a computer program that is being executed by one or many threads. It contains the program code and its activity. Depending on the operating system (<strong>OS</strong>), a process may be made up of multiple threads of execution that execute instructions concurrently. And a process entity consists of code segment, data segment and process control block (<strong>PCB</strong>). Actually, a process is an execution of a process entity.</li><li><p>In general, a computer system process consists of (or is said to own) the following resources. The operating system keeps its processes separate and allocates the resources they need, so that they are less likely to interfere with each other and cause system failures (e.g., deadlock or thrashing). The operating system may also provide mechanisms for inter-process communication to enable processes to interact in safe and predictable ways.</p> <a id="more"></a><ul><li><p>An image of the executable machine code associated with a program.</p></li><li><p>Memory (typically some region of virtual memory), which includes the executable code, process-specific data (input and output), a call stack (to keep track of active subroutines and/or other events), and a heap to hold intermediate computation data generated during run time.</p></li><li><p>Operating system descriptors of resources that are allocated to the process, such as file descriptors (Unix terminology) or handles (Windows), and data sources and sinks.</p></li><li><p>Security attributes, such as the process owner and the process’ set of permissions (allowable operations).</p></li><li><p>Processor state (context), such as the content of registers and physical memory addressing. The state is typically stored in computer registers when the process is executing, and in memory otherwise.</p></li></ul></li><li>In order for programs (including data) that participate in parallel execution to run independently, they must be assigned a specialized data structure (<strong>tack_struct</strong>) called a process control block (<strong>PCB</strong>). The system uses a process control block to describe the basic situation and running state of the process in order to control and manage the process itself, such as creating or destroying a process. </li></ol><h3 id="Process-States"><a href="#Process-States" class="headerlink" title="Process States"></a>Process States</h3><ol><li><p><code>ps [options]</code>: display information about a selection of the active processes. Usually, we use <strong>-aux</strong> or <strong>-ef</strong> options to see some process information in Linux. Different status of the process are showed as below</p><ul><li><code>D</code>: uninterruptible sleep (usually <strong>IO</strong>)</li><li><code>I</code>: idle kernel thread</li><li><code>R</code>: running or runnable (on run queue)</li><li><code>S</code>: interruptible sleep (waiting for an event to complete)</li><li><code>T</code>: stopped by job control signal</li><li><code>t</code>: stopped by debugger during the tracing</li><li><code>X</code>: dead (should never be seen)</li><li><code>Z</code>: defunct (zombie) process, terminated but not reaped by its parent</li></ul></li><li><p>For <strong>BSD</strong> formats and when the stat keyword is used, additional characters may be displayed as below</p><ul><li><p><code>&lt;</code>: high-priority (not nice to other users)</p></li><li><p><code>N</code>: low-priority (nice to other users)</p></li><li><p><code>L</code>: has pages locked into memory (for real-time and custom <strong>IO</strong>)</p></li><li><p><code>s</code>: is a session leader</p></li><li><p><code>l</code>: is multi-threaded</p></li><li><p><code>+</code>: is in the foreground process group</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definition in task_struct in head file 'sched.h'</span></span><br><span class="line"><span class="comment">/* Used in tsk-&gt;state: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_RUNNING                    0x0000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_INTERRUPTIBLE              0x0001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_UNINTERRUPTIBLE            0x0002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TASK_STOPPED                  0x0004</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TASK_TRACED                   0x0008</span></span><br><span class="line"><span class="comment">/* Used in tsk-&gt;exit_state: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_DEAD                       0x0010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_ZOMBIE                     0x0020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_TRACE                      (EXIT_ZOMBIE | EXIT_DEAD)</span></span><br><span class="line"><span class="comment">/* Used in tsk-&gt;state again: */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_PARKED                     0x0040</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_DEAD                       0x0080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_WAKEKILL                   0x0100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_WAKING                     0x0200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_NOLOAD                     0x0400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_NEW                        0x0800</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_STATE_MAX                  0x1000</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><ol><li>The switch of process states<br><img src="/img/processStatusSwitch.png" alt="process_status_switch"></li></ol><ul><li><p>Three-state process management model: at any instant, a process is in one and only one of the three states. For a single processor computer, only one process can be in the “running” state at any one instant.</p><ul><li><strong>CREATED</strong> $ \rightarrow$ <strong>READY</strong>: the process is “created” by being loaded from a secondary storage device (hard disk drive, CD-ROM, etc.) into main memory. After that the process scheduler assigns it the “ready” state.</li><li><strong>READY</strong> $\rightarrow$ <strong>RUNNING</strong>: it waits for the scheduler to do a so-called context switch and load the process into the processor. Processes that are ready for execution by the <strong>CPU</strong> are maintained in a queue for ready processes. The process state then becomes “running”, and the processor executes the process instructions. </li><li><strong>RUNNING</strong> $\rightarrow$ <strong>READY</strong>: the most common reason for this transition is that the running process has reached the maximum allowable time for uninterrupted execution; i.e. time-out occurs. Other reasons can be the imposition of priority levels as determined by the scheduling policy used for the Low Level Scheduler, and the arrival of a higher priority process into the “ready” state.</li><li><strong>RUNNING</strong> $\rightarrow$ <strong>BLOCKED</strong> Whenever the process requests access to <strong>I/O</strong> or needs input from the user or needs access to a critical region (the lock for which is already acquired) it enters the “blocked” state. The process continues to wait in the main memory and does not require <strong>CPU</strong>.</li><li><strong>BLOCKED</strong> $\rightarrow$ <strong>READY</strong>: Once the <strong>I/O</strong> operation is completed the process goes to the “ready” state.</li><li><strong>RUNNING</strong> $\rightarrow$ <strong>TERMINATED</strong>: Once the process finishes execution, or is terminated by the operating system, it is no longer needed. The process is removed instantly or is moved to the “terminated” state. When removed, it just waits to be removed from main memory.<ul><li>Five-state process management model: the Medium Level Scheduler controls these events. A process can be suspended from the “running”, “blocked” and “ready” state, giving rise to two other states, namely, “suspend ready” and “suspend blocked”. A “ready” process that is suspended becomes “suspend ready”, and a “blocked” process that is suspended becomes “suspend blocked”. A process can be suspended for a number of reasons; the most significant of which arises from the process being swapped out of memory by the memory management system in order to free memory for other processes. Other common reasons for a process being suspended are when one suspends execution while debugging a program, or when the system is monitoring processes. Normally, the <strong>OS</strong> would be designed so that the preference would be to suspend a “blocked” process rather than a “ready” one.</li></ul></li><li><strong>BLOCKED</strong> $\rightarrow$ <strong>SUSPEND BLOCKED</strong>: If a process in the “running” state requires more memory, then at least one “blocked” process can be swapped out of memory onto disk. The transition can also be made for the “blocked” process if there are “ready” processes available, and the <strong>OS</strong> determines that the “ready” process it would like to dispatch requires more main memory to maintain adequate performance.</li><li><strong>SUSPEND BLOCKED</strong> $\rightarrow$ <strong>SUSPEND READY</strong>: A process in the “suspend blocked” state is moved to the “suspend ready” state when the event for which it has been waiting occurs. Note that this requires the state information concerning suspended processes be accessible to the <strong>OS</strong>.</li><li><strong>SUSPEND READY</strong> $\rightarrow$ <strong>READY</strong>: When there are no “ready” processes in main memory, the <strong>OS</strong> will need to bring one in to continue execution. In addition, it might be the case that a process in the “suspend ready” state has higher priority than any of the processes in the “ready” state. In that case, the <strong>OS</strong> designer may dictate that it is more important to get at the higher priority process than to minimise swapping.</li></ul></li></ul><h3 id="Process-Creation"><a href="#Process-Creation" class="headerlink" title="Process Creation"></a>Process Creation</h3><ol><li><p>Creation of a program</p><ul><li>The compiler compiles the startup routine into the executable file during compiling. And the startup routine pass the argument in the command line to the main function with some environment variables. </li></ul></li><li><p>Creation of a process: process creation in UNIX and Linux are done through <code>fork()</code> or <code>clone()</code> system calls. There are several steps involved in process creation. The first step is the validation of whether the parent process has sufficient authorization to create a process. Upon successful validation, the parent process is copied almost entirely, with changes only to the unique process id, parent process, and user-space. Each new process gets its own user space.</p><ul><li><p><code>int atexit(void (*function)(void));</code>: register the given function to be called at normal process termination, either via <u>exit</u>() or via return from the program’s <u>main</u>(). It returns the value 0 if successful, otherwise it returns a nonzero value. Multiple registered termination functions are executed in a stack fashion.</p></li><li><p><code>pid_t fork(void);</code>: create a new process by duplicating the calling process. The new process is referred to as the <strong>child</strong> process. The calling process is referred to as the <strong>parent</strong> process. The child process and the parent process run in separate memory spaces. At the time of <u>fork</u>() both memory spaces have the same content. Memory writes, file mappings, and unmappings performed by one of the processes do not affect the other. On success, the <strong>PID</strong> of the child process is returned in the parent, and 0 is returned in the child. On failure, -1 is returned in the parent, no child process is created, and <strong>errno</strong> is set appropriately. The child inherits copies of the parent’s set of open file descriptors. Each file descriptor in the child refers to the same open file description as the corresponding file descriptor in the parent. This means that the two file descriptors share open file status flags, file offset, and signal-driven <strong>I/O</strong> attributes. Also we can use <code>uid_t getuid(void);</code>, <code>uid_t geteuid(void);</code>, <code>gid_t getgid(void);</code>, <code>gid_t getegid(void);</code>, <code>pid_t getpid(void);</code>, <code>pid_t getppid(void);</code>, <code>pid_t getpgid(pid_t pid);</code> to get some identifiers about the process.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the caching mechanism</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"current pid: %d\n"</span>, getpid());</span><br><span class="line">    FILE* fp = fopen(<span class="string">"test1.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"test2.txt"</span>, O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU | S_IRWXG);</span><br><span class="line">    <span class="keyword">char</span>* s_1 = <span class="string">"parent"</span>;</span><br><span class="line">    <span class="keyword">char</span>* s_2 = <span class="string">"child"</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s"</span>, s_1);</span><br><span class="line">            write(fd, s_1, <span class="number">6</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"This is parent process pid is: %d\n"</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(fp, <span class="string">"%s"</span>, s_2);</span><br><span class="line">            write(fd, s_2, <span class="number">5</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"This is child process pid is:%d\n"</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="Process-Termination"><a href="#Process-Termination" class="headerlink" title="Process Termination"></a>Process Termination</h3><ol><li><p>Two ways to end a process</p><ul><li><p>Two conditions of process ending: mainly there is normal end and abnormal end. Thereamong, the normal end is divided into the <strong>return</strong> function calling and the <code>exit()</code> function (standard library function) calling or the <code>_exit()</code> and <code>_Exit()</code> function (system calling function) calling, while the abnormal end is divided into the <code>abort()</code> function calling and the reception of an abnormal signal. The difference between return, exit and _exit is as below.</p></li><li><table style="text-align:center">    <tr>        <td></td>        <td width="60px">return</td>        <td width="60px">exit()</td>        <td width="60px">_exit()</td>    </tr>    <tr>        <td>Whether flush standard I/O cache</td>        <td>Yes</td>        <td>Yes</td>        <td>No</td>    </tr>    <tr>        <td>Whether automatically to call the atexit() funcion</td>        <td>Yes</td>        <td>Yes</td>        <td>No</td>    </tr></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the stack of atexit()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">term_fun1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"first term function\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">term_fun2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"second term function\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">term_fun3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"third term function\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"useage: %s file [exit|_exit|return]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    atexit(term_fun1);</span><br><span class="line">    atexit(term_fun2);</span><br><span class="line">    atexit(term_fun3);</span><br><span class="line"></span><br><span class="line">    FILE* fp = fopen(argv[<span class="number">1</span>], <span class="string">"w"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">"hello YouthFaith!\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">"exit"</span>)) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">"_exit"</span>)) &#123;</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">"return"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"useage: %s file [exit|_exit|return]\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Process-Chain-and-Process-Fan"><a href="#Process-Chain-and-Process-Fan" class="headerlink" title="Process Chain and Process Fan"></a>Process Chain and Process Fan</h2><h3 id="Process-Chain"><a href="#Process-Chain" class="headerlink" title="Process Chain"></a>Process Chain</h3><p><img src="/img/process_chain.png" alt="process chain"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a process chain</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">        counter = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        counter = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counter; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pid: %d, ppid: %d\n"</span>, getpid(), getppid());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Process-Fan"><a href="#Process-Fan" class="headerlink" title="Process Fan"></a>Process Fan</h3><p><img src="/img/process_fan.png" alt="process fan"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a process fan</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">        counter = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        counter = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; counter; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pid: %d, ppid: %d\n"</span>, getpid(), getppid());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Defunct-Process"><a href="#Defunct-Process" class="headerlink" title="Defunct Process"></a>Defunct Process</h2><ol><li><p>Concept of the defunct process: a process that has completed execution (via the <u>exit</u>() system call) but still has an entry in the process table. This occurs for child processes, where the entry is still needed to allow the parent process to read its child’s exit status. Once the exit status is read via the <u>wait</u>() system call, the zombie’s entry is removed from the process table and it is said to be <strong>reaped</strong>. A child process always first becomes a zombie before being removed from the resource table. In most cases, under normal system operation zombies are immediately waited on by their parent and then reaped by the system – processes that stay zombies for a long time are generally an error and cause a resource leak.</p></li><li><p>Three methods to avoid generate defunct process:</p><ul><li>Set the <strong>SIGCHLD</strong> handler to <strong>SIG_IGN</strong>.</li><li>Using the <strong>wait()</strong> or <strong>waitpid()</strong> system calling function to let its parent process to reap it.</li><li>Convert it to an orphan process, and that means ending its parent process and the <strong>init</strong> process will reap it finally.</li></ul></li><li><p><code>pid_t wait(int *stat_loc);</code> or <code>pid_t waitpid(pid_t pid, int *stat_loc, int options);</code>: obtain status information pertaining to one of the caller’s child processes. Various options permit status information to be obtained for child processes that have terminated or stopped. If status information is available for two or more child processes, the order in which their status is reported is unspecified. The <u>wait</u>() function shall <strong>suspend</strong> execution of the calling thread until status information for one of the terminated child processes of the calling process is available, or until delivery of a signal whose action is either to execute a signal-catching function or to terminate the process, while whether or not the thread is blocked depends on the value of the <strong>pid</strong> for the <strong>waitpid()</strong> function. If <strong>pid</strong> is equal to −1, status is requested for any child process. In this respect, <u>waitpid</u>() is then equivalent to <u>wait</u>(). If <strong>pid</strong> is greater than 0, it specifies the process ID of a single child process for which status is requested. If <strong>pid</strong> is 0, status is requested for any child process whose process group ID is equal to that of the calling process. If <strong>pid</strong> is less than −1, status is requested for any child process whose process group ID is equal to the absolute value of <strong>pid</strong>. The <strong>options</strong> argument is constructed by zero or more of the following flags, <strong>WCONTINUED</strong>, <strong>WNOHANG</strong> or <strong>WUNTRACED</strong>. And regardless of its value, this information may be interpreted using the following macros, <strong>WIFEXITED(stat_val)</strong> and <strong>WEXITSTATUS(stat_val)</strong>, <strong>WIFSIGNALED(stat_val)</strong> and <strong>WTERMSIG(stat_val)</strong>, <strong>WIFSTOPPED(stat_val)</strong> and <strong>WSTOPSIG(stat_val)</strong>. If <u>wait</u>() or <u>waitpid</u>() returns because the status of a child process is available, these functions shall return a value equal to the process ID of the child process for which <strong>status</strong> is reported. If <u>wait</u>() or <u>waitpid</u>() returns due to the delivery of a signal to the calling process, −1 shall be returned and <strong>errno</strong> set to <strong>[EINTR]</strong>. If <strong>waitpid()</strong> was invoked with <strong>WNOHANG</strong> set in options, it has at least one child process specified by <strong>pid</strong> for which <strong>status</strong> is not available, and <strong>status</strong> is not available for any process specified by <strong>pid</strong>, 0 is returned. Otherwise, −1 shall be returned, and <strong>errno</strong> set to indicate the error.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// three different status value about wait()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_statue</span><span class="params">(<span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"normal exit:%d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"abnormal term:%d\n"</span>, WTERMSIG(status));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSTOPPED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"stopped sig:%d\n"</span>, WSTOPSIG(status));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"unknow sig\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pid:%d, ppid:%d\n"</span>, getpid(), getppid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    out_statue(status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pid:%d, ppid:%d\n"</span>, getpid(), getppid());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">3</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i / j;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    out_statue(status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pid:%d, ppid:%d\n"</span>, getpid(), getppid());</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        pid = waitpid(pid, &amp;status, WNOHANG | WUNTRACED);</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (pid == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// use `kill -19 PID` to stop the child process</span></span><br><span class="line">    out_statue(status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Daemon-Process"><a href="#Daemon-Process" class="headerlink" title="Daemon Process"></a>Daemon Process</h2><ol><li><p>Concept of the daemon process: a computer program that runs as a background process, rather than being under the direct control of an interactive user. Traditionally, the process names of a daemon end with the letter <strong>d</strong>, for clarification that the process is in fact a daemon. And the parent process of a daemon is often, but not always, the <strong>init</strong> process. A daemon is usually either created by a process forking a child process and then immediately exiting, thus causing <strong>init</strong> to adopt the child process, or by the <strong>init</strong> process directly launching the daemon.</p></li><li><p>Implementations</p><ul><li><p>Changing the umask to 0 to allow <code>open()</code>, <code>creat()</code>, and other operating system calls to provide their own permission masks and not to depend on the umask of the caller.</p></li><li><p>Executing as a background task by forking and exiting (in the parent “half” of the fork). This allows daemon’s parent (shell or startup process) to receive exit notification and continue its normal execution.</p></li><li><p>Detaching from the invoking session (usually accomplished by a single operation, <code>setsid()</code></p><ul><li>Dissociating from the controlling tty.</li><li>Creating a new session and becoming the session leader of that session.</li><li>Becoming a process group leader.</li></ul></li><li><p>Setting the root directory (<strong>‘/‘</strong>) as the current working directory so that the process does not keep any directory in use that may be on a mounted file system (allowing it to be unmounted).</p></li><li><p>Closing all inherited files at the time of execution that are left open by the parent process, including file descriptors 0, 1 and 2 for the standard streams (stdin, stdout and stderr). Required files will be opened later. Using a logfile, the console, or <code>/dev/null</code> as stdin, stdout, and stderr.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implement daemon process</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setsid();</span><br><span class="line"></span><br><span class="line">    chdir(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    close(STDIN_FILENO);</span><br><span class="line">    close(STDOUT_FILENO);</span><br><span class="line">    close(STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    openlog(argv[<span class="number">0</span>], LOG_PID, LOG_SYSLOG);</span><br><span class="line">    syslog(LOG_DEBUG, <span class="string">"test syslog"</span>);</span><br><span class="line">    <span class="comment">// cat /var/log/syslog | grep ProcessName</span></span><br><span class="line">    closelog();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Common functions about system log</p><ul><li><code>void openlog(const char *ident, int option, int facility);</code>: opens a connection to the system logger for a program. The string pointed to by <em>ident</em> is prepended to every message, and is typically set to the program name. If <em>ident</em> is <strong>NULL</strong>, the program name is used. The <em>option</em> argument specifies flags which control the operation of <u>openlog</u>() and subsequent calls to <u>syslog</u>(). The facility argument establishes a default to be used if none is specified in subsequent calls to <u>syslog</u>(). The values that may be specified for option and facility are described below.</li></ul></li></ol><ul><li><p>The <em>option</em> argument to <u>openlog</u>() is a bit mask constructed by ORing together any of the following values.</p><ul><li><strong>LOG_CONS</strong>: write directly to the system console if there is an error while sending to the system logger.</li><li><strong>LOG_NDELAY</strong>: open the connection immediately (normally, the connection is opened when the first message is logged).</li><li><strong>LOG_PERROR</strong>: also log the message to stderr.</li><li><strong>LOG_PID</strong>: include the caller’s PID with each message.</li></ul></li><li><p>The facility argument is used to specify what type of program is logging the message. This lets the configuration file specify that messages from different facilities will be handled differently.</p><ul><li><strong>LOG_AUTH</strong>: security/authorization messages</li><li><strong>LOG_AUTHPRIV</strong>: security/authorization messages (private)</li><li><strong>LOG_CRON</strong>: clock daemon (cron and at)</li><li><strong>LOG_DAEMON</strong>: system daemons without separate facility value </li><li><strong>LOG_FTP</strong>: ftp daemon</li><li><strong>LOG_KERN</strong>: kernel messages (these can’t be generated from user processes)</li><li><strong>LOG_LPR</strong>: line printer subsystem</li><li><strong>LOG_MAIL</strong>: mail subsystem</li><li><strong>LOG_NEWS</strong>: USENET news subsystem</li><li><strong>LOG_SYSLOG</strong>: messages generated internally by syslogd(8)</li><li><strong>LOG_USER</strong>: (default)generic user-level messages</li><li><strong>LOG_UUCP</strong>: UUCP subsystem</li></ul></li><li><p><code>void syslog(int priority, const char *format, ...);</code>: generates a log message. The priority argument is formed by ORing together a facility value and a level value (described below). If no facility value is ORed into priority, then the default value set by <u>openlog</u>() is used, or, if there was no preceding <u>openlog</u>() call, a default of <strong>LOG_USER</strong> is employed.</p><ul><li><p>This determines the importance of the message. The levels are, in order of decreasing importance.</p><ul><li><strong>LOG_EMERG</strong>: system is unusable</li><li><p><strong>LOG_ALERT</strong>: action must be taken immediately</p></li><li><p><strong>LOG_CRIT</strong>: critical conditions</p></li><li><p><strong>LOG_ERR</strong>: error conditions</p></li><li><p><strong>LOG_WARNING</strong>: warning conditions</p></li><li><p><strong>LOG_NOTICE</strong>: normal, but significant, condition</p></li><li><p><strong>LOG_INFO</strong>: informational message</p></li></ul></li><li><strong>LOG_DEBUG</strong>: debug-level message</li></ul></li><li><p><code>void closelog(void);</code>: closes the file descriptor being used to write to the system logger.</p></li></ul><h2 id="Run-Other-applications"><a href="#Run-Other-applications" class="headerlink" title="Run Other applications"></a>Run Other applications</h2><ul><li>The exec function family: execute the program pointed to by filename. This causes the program that is currently being run by the calling process to be replaced with a new program, with newly initialized stack, heap, and (initialized and uninitialized)data segments. On success, they does not return, on error -1 is returned, and <strong>errno</strong> is set appropriately.<ul><li><code>int execve(const char *filename, char *const argv[], char *const envp[]);</code></li><li><code>`int execl(const char *path, const char *arg,...(char*)NULL);</code></li><li><code>int execlp(const char *file, const char *arg,...(char*)NULL);</code></li><li><code>int execle(const char *path, const char *arg,...(char*)NULL, char* const envp[]);</code></li><li><code>`int execv(const char *path, char *const argv[]);</code></li><li><code>int execvp(const char *file, char *const argv[]);</code></li><li><code>`int execvpe(const char *file, char *const argv[], char *const envp[]);</code></li></ul></li><li><code>int system(const char *command);</code>: use <u>fork</u>() to create a child process that executes the shell command. The return value is one of the following<ul><li>If command is <strong>NULL</strong>, then a nonzero value if a shell is available, or 0 if no shell is available.</li><li>If a child process could not be created, or its status could not be retrieved, the return value is -1.</li><li>If a shell could not be executed in the child process, then the return value is as though the child shell terminated by calling <u>_exit</u>() with the status 127.</li><li>If all system calls succeed, then the return value is the termination status of the child shell used to execute command. (The termination status of a shell is the termination status of the last command it executes)</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ultimate Knowledge </tag>
            
            <tag> OS System </tag>
            
            <tag> C Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Common Linux Commands</title>
      <link href="/2018/12/01/CommonLinuxCommands/"/>
      <url>/2018/12/01/CommonLinuxCommands/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>The talent of success is nothing more than doing well whatever you do without a thought of time.</p></blockquote><h2 id="Linux-Commands"><a href="#Linux-Commands" class="headerlink" title="Linux Commands"></a>Linux Commands</h2><h3 id="Concept-of-Linux-Commands"><a href="#Concept-of-Linux-Commands" class="headerlink" title="Concept of Linux Commands"></a>Concept of Linux Commands</h3><p>&emsp;A Linux command is a command that manages a Linux system. For a Linux system, whether the CPU, memory, disk drive, keyboard, mouse, or user is a file, Linux system management command is the core of its normal operation. There are two types of Linux commands on the system: built-in Shell commands and Linux commands. The command format is <code>command [option] [arguments]</code>.<br><a id="more"></a></p><h2 id="Some-common-commands-for-Linux"><a href="#Some-common-commands-for-Linux" class="headerlink" title="Some common commands for Linux"></a>Some common commands for Linux</h2><h3 id="Help"><a href="#Help" class="headerlink" title="Help"></a>Help</h3><ul><li><code>man command</code> or <code>info command</code>: an interface to the on-line reference manuals</li><li><code>whatis command</code>: display one-line manual page descriptions</li><li><code>apropos command</code>: search the manual page names and descriptions</li><li><code>help command</code> or <code>command --help</code>: display information about built-in commands </li><li><code>type command</code>: write a description of command type</li></ul><h3 id="File-Processing"><a href="#File-Processing" class="headerlink" title="File Processing"></a>File Processing</h3><ul><li><code>ls [OPTION]... [FILE]...</code>: list information about the files (the current directory by default)<ul><li><code>-a</code>: do not ignore entries starting with</li><li><code>-l</code>: use a long listing format</li><li><code>-d</code>: list directories themselves, not their contents</li></ul></li><li><code>mkdir [OPTION]... DIRECTORY...</code>: create the directory if they do not already exist<ul><li><code>-p</code>: no error if existing, make parent directories as needed</li></ul></li><li><code>cd DIRECTORY</code>: change the current directory (home directory by default)</li><li><code>pwd [OPTION]...</code>: print the full filename of the current working directory</li><li><code>rmdir [OPTION]... DIRECTORY...</code>: remove the directories if they are empty<ul><li><code>-p</code>: remove  directory and  its ancestors</li></ul></li><li><code>cp [OPTION]... SOURCE... DIRECTORY</code>: copy source to destination</li><li><code>mv [OPTION]... SOURCE... DIRECTORY</code>: rename or move source to destination</li><li><code>rm [OPTION]... [FILE]...</code>: remove files or directories (with -r option)<ul><li><code>-r</code>: remove directories and their contents recursively</li><li><code>-f</code>: ignore nonexistent files and arguments, never prompt</li></ul></li><li><code>touch [OPTION]... FILE...</code>: create a empty file that does not exist or update the access and modification times of each file to the current time</li><li><code>cat [OPTION]... [FILE]...</code>: concatenate files to standard output</li><li><code>more [options] file...</code>: a filter for paging through text one screenful at a time</li><li><code>less [options] file...</code>: a program similar to more, but it has many more features</li><li><code>head [OPTION]... [FILE]...</code>: print the first 10 lines of each file to standard output</li><li><code>tail [OPTION]... [FILE]...</code>: print the last 10 lines of each file to standard output<ul><li><code>-f</code>: output appended data as the file grows</li></ul></li><li><code>ln [OPTION]... [-T] TARGET LINK_NAME</code>: make links between files, consisting of hard link and symbolic link</li></ul><h3 id="File-Search"><a href="#File-Search" class="headerlink" title="File Search"></a>File Search</h3><ul><li><code>find  [-H]  [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression]</code>: search for files in a directory hierarchy <ul><li><code>find DIR CONDITION -exec COMMAND {}\;</code></li><li><code>find DIR CONDITION | xargs COMMAND</code></li><li><code>find DIR CONDITION | grep &quot;String&quot;</code> </li></ul></li><li><code>locate [OPTION]... PATTERN...</code>: find files by name</li><li><code>updatedb [OPTION]...</code>: update a database for mlocate</li><li><code>which [-a] filename ...</code>: locate a command</li><li><code>whereis [options] [-BMS directory... -f] name...</code>: locate the binary, source, and manual page files for a command</li><li><code>grep [OPTION...] PATTERNS [FILE...]</code>: print lines that match patterns<ul><li><code>-i</code>: ignore case distinctions, so that characters that differ only  in  case  match  each other</li></ul></li></ul><h3 id="User-Administration"><a href="#User-Administration" class="headerlink" title="User Administration"></a>User Administration</h3><ul><li><code>useradd [options] LOGIN</code>: create a new user or update default new user information</li><li><code>passwd [options] [LOGIN]</code>: change user password</li><li><code>who [OPTION]... [ FILE | ARG1 ARG2 ]</code>: show who is logged on</li><li><code>w [options] user [...]</code>: show who is logged on and what they are doing.</li></ul><h3 id="Archiving-Utility"><a href="#Archiving-Utility" class="headerlink" title="Archiving Utility"></a>Archiving Utility</h3><ul><li><code>.gz$$\rightarrow$$gzip, gunzip</code>: compress or expand files</li><li><code>.tar$$\rightarrow$$tar -cvf, tar -xvf</code>: an archiving utility</li><li><code>.tar.gz$$\rightarrow$$tar -zcf, tar -zxf</code>:  an archiving utility</li><li><code>.tar.bz2$$\rightarrow$$tar -jcf, tar -jxf</code>:  an archiving utility</li><li><code>.zip$$\rightarrow$$zip, unzip</code>: package and compress(archive) files</li><li><p><code>.bz2$$\rightarrow$$bzip2, bunzip2</code>: a block-sorting file compressor</p><h3 id="Network-Management"><a href="#Network-Management" class="headerlink" title="Network Management"></a>Network Management</h3></li><li><p><code>ping destination</code>: send ICMP ECHO_REQUEST to network hosts</p><ul><li><code>-c</code>: stop after sending count ECHO_REQUEST packets.</li></ul></li><li><code>ifconfig [-v] [-a] [-s] [interface]</code>: show or configure a network interface</li><li><code>last [options] [username...] [tty...]</code>: show a listing of last logged in users</li><li><code>lastlog [options]</code>: reports the most recent login of all users or of a given user</li><li><code>nslookup</code>: query Internet name servers interactively</li><li><code>traceroute host</code>: print the route packets trace to network host</li><li><code>netstat</code>: print network connections, routing tables, interface statistics, masquerade connections and multi-cast memberships<ul><li><code>netstat -tuln</code>: view the port on which the native listener is listening</li><li><code>netstat -an</code>: check the local all get network connection</li><li><code>netstat -rn</code>: show / manipulate the IP routing table and is equivalent to <code>route</code> command</li></ul></li><li><code>mount [-fnrsvw] [-t fstype] [-o options] device dir</code> or <code>umount</code>: mount and umount a file-system.</li></ul><h3 id="System-Management"><a href="#System-Management" class="headerlink" title="System Management"></a>System Management</h3><ul><li><code>clear</code>: clear the terminal screen</li><li><code>umane</code>: print system information<ul><li><code>-a</code>: print  all  information</li></ul></li><li><code>shutdown [OPTIONS...] [TIME] [WALL...]</code>: halt, power-off or reboot the machine<ul><li><code>-r</code>: reboot the machine</li></ul></li><li><code>runlevel [options...]</code>: print previous and current system runlevel</li><li><code>login, logout</code>: write utmp and wtmp entries</li><li><code>crontab</code>: maintain crontab files for individual users<ul><li><code>-e</code>: be used to edit the  current  crontab and use <code>sudo service cron restart</code> command to restart  cron service</li></ul></li><li><code>free</code>: display amount of free and used memory in the system</li><li><code>df</code>: report file system disk space usage<ul><li><code>-h</code>: print sizes in powers of 1024</li></ul></li><li><code>du</code>: estimate file space usage<ul><li><code>-h</code>: print sizes in powers of 1024</li><li><code>-s</code>: display only a total for each argument</li></ul></li><li><code>fdisk</code>: manipulate disk partition table<ul><li><code>-l</code>: List  the  partition  tables  for the specified devices and then exit.  If no devices are given, those mentioned in  <u>/proc/partitions</u> (if that file exists) are used.</li></ul></li></ul><h3 id="Package-Management"><a href="#Package-Management" class="headerlink" title="Package Management"></a>Package Management</h3><ul><li><code>dpkg [option...] action</code>: package manager for Debian</li><li><code>apt-get</code>: apt package handling utility<ul><li><code>update</code>: resynchronize the package index files from their sources</li><li><code>upgrade</code>: install the newest versions of all packages currently</li><li><code>install</code>: followed by one or more packages desired for installation or upgrading</li><li><code>remove</code>: identical to install except that packages are removed instead of installed.</li><li><code>purge</code>: identical to remove except that packages are removed and purged (any configuration files are deleted too)</li></ul></li></ul><h3 id="Process-Management"><a href="#Process-Management" class="headerlink" title="Process Management"></a>Process Management</h3><ul><li><code>ps [options]</code>: report a snapshot of the current processes<ul><li><code>-aux</code>: see every process on the system using BSD syntax</li><li><code>-ef</code>: see every process on the system using standard syntax</li></ul></li><li><code>pstree</code>: show running processes as a tree<ul><li><code>-p</code>: Show PIDs</li></ul></li><li><code>top</code>: provides a dynamic real-time  view  of  a  running system<ul><li><code>-p</code>: monitor  only processes with specified process IDs</li></ul></li><li><code>kill [options] &lt;pid&gt; [...]</code>: send a signal to a process</li></ul><h3 id="User-Management"><a href="#User-Management" class="headerlink" title="User Management"></a>User Management</h3><ol><li><code>useradd [options] LOGIN</code>: create a new user or update default new user information<ul><li><code>-m</code>: create the user’s home directory if it does not exist. The files and directories contained in the skeleton directory will be copied to the home directory.</li></ul></li><li><code>userdel [options] LOGIN</code>: delete a user account and related files<ul><li><code>-r</code>: files in the user’s home directory will be removed along with the home directory itself and the user’s mail spool.</li></ul></li><li><code>passwd [options] [LOGIN]</code>: change user password</li><li><code>whoami [OPTION]...</code>: print effective user ID</li><li><code>who [OPTION]... [ FILE | ARG1 ARG2 ]</code>: show who is logged on</li><li><code>id [OPTION]... [USER]</code>: print real and effective user and group IDs<ul><li><code>-u</code>: print only the effective user ID</li></ul></li><li><code>su [options] [-] [user [argument...]]</code>: run a command with substitute user and group ID (root by default)</li><li><code>sudo [-u user] [command]</code>: allow a permitted user to execute a command as the superuser or another user, as specified by the security policy</li><li><code>usermod [options] LOGIN</code>: modify a user account<ul><li><code>-L</code>: lock a user’s password.</li><li><code>-U</code>: unlock a user’s password.</li></ul></li><li><code>groupadd [options] group</code>: create a new group</li><li><code>groupdel [options] GROUP</code>: delete a group</li><li><code>groups [OPTION]... [USERNAME]...</code>: print the groups a user is in</li><li><code>gpasswd [option] group</code>: administer <u>/etc/group</u> and <u>/etc/gshadow</u><ul><li><code>-a</code>: add the user to the named group.</li><li><code>-d</code>: remove the user from the named group.</li></ul></li><li><code>newgrp [-] [group]</code>: change the current group ID during a login session.</li></ol><h3 id="Authority-Management"><a href="#Authority-Management" class="headerlink" title="Authority Management"></a>Authority Management</h3><ul><li><code>chmod [OPTION]... MODE[,MODE]... FILE...</code>: change file mode bits</li><li><code>chown [OPTION]... [OWNER][:[GROUP]] FILE...</code>: change file owner and group<ul><li><code>-R</code>: operate on files and directories recursively.</li></ul></li><li><code>chgrp [OPTION]... GROUP FILE...</code>: change group ownership<ul><li><code>-R</code>: operate on files and directories recursively.</li><li><code>umask [−S] [mask]</code>: get or set the file mode creation mask</li></ul></li></ul><h2 id="FTP-Server"><a href="#FTP-Server" class="headerlink" title="FTP Server"></a>FTP Server</h2><h3 id="Concept-of-FTP"><a href="#Concept-of-FTP" class="headerlink" title="Concept of FTP"></a>Concept of FTP</h3><ol><li><strong>The</strong> File Transfer Protocol (<strong>FTP</strong>) is a standard network protocol used for the transfer of computer files between a client and server on a computer network.</li><li><strong>FTP</strong> is built on a client-server model architecture using separate control and data connections between the client and the server. <strong>FTP</strong> users may authenticate themselves with a clear-text sign-in protocol, normally in the form of a username and password, but can connect anonymously if the server is configured to allow it. For secure transmission that protects the user-name and password, and encrypts the content, <strong>FTP</strong> is often secured with <strong>SSL</strong>/<strong>TLS</strong> (<strong>FTPS</strong>) or replaced with <strong>SSH</strong> File Transfer Protocol (<strong>SFTP</strong>).</li></ol><h3 id="Communication-and-Data-Transfer"><a href="#Communication-and-Data-Transfer" class="headerlink" title="Communication and Data Transfer"></a>Communication and Data Transfer</h3><ol><li><strong>FTP</strong> may run in <em>active</em> or <em>passive</em> mode, which determines how the data connection is established. In both cases, the client creates a <strong>TCP</strong> control connection from a random, usually an unprivileged, port <strong>N</strong> to the <strong>FTP</strong> server command port 21.<ul><li>In active mode, the client starts listening for incoming data connections from the server on port <strong>M</strong>. It sends the <strong>FTP</strong> command “<strong>PORT M</strong>“ to inform the server on which port it is listening. The server then initiates a data channel to the client from its port 20, the <strong>FTP</strong> server data port.</li><li>In situations where the client is behind a firewall and unable to accept incoming <strong>TCP</strong> connections, <em>passive mode</em> may be used. In this mode, the client uses the control connection to send a <strong>PASV</strong> command to the server and then receives a server <strong>IP</strong> address and server port number from the server, which the client then uses to open a data connection from an arbitrary client port to the server <strong>IP</strong> address and server port number received.</li></ul></li><li>While transferring data over the network, four data representations can be used.<ul><li><strong>ASCII mode</strong>: used for text. Data is converted, if needed, from the sending host’s character representation to “8-bit ASCII” before transmission, and (again, if necessary) to the receiving host’s character representation. As a consequence, this mode is inappropriate for files that contain data other than plain text.</li><li><strong>Image mode</strong> (commonly called Binary mode): the sending machine sends each file byte by byte, and the recipient stores the byte-stream as it receives it. (Image mode support has been recommended for all implementations of <strong>FTP</strong>).</li><li><strong>EBCDIC mode</strong>: used for plain text between hosts using the <strong>EBCDIC</strong> character set.</li><li><strong>Local mode</strong>: allows two computers with identical setups to send data in a proprietary format without the need to convert it to <strong>ASCII</strong>.</li></ul></li></ol><h3 id="Usage-of-FTP-Command"><a href="#Usage-of-FTP-Command" class="headerlink" title="Usage of FTP Command"></a>Usage of FTP Command</h3><ol><li>Installation of <strong>FTP</strong> server: <code>sudo apt-get install vsftpd</code>.</li><li>Login command: <code>ftp  ipaddress</code>.</li></ol><h2 id="SSH-Server"><a href="#SSH-Server" class="headerlink" title="SSH Server"></a>SSH Server</h2><h3 id="Concept-of-SSH"><a href="#Concept-of-SSH" class="headerlink" title="Concept of SSH"></a>Concept of SSH</h3><ol><li>Secure Shell (<strong>SSH</strong>) is a cryptographic network protocol for operating network services securely over an unsecured network. Typical applications include remote command-line, login, and remote command execution, but any network service can be secured with <strong>SSH</strong>.</li><li>SSH was designed as a replacement for Telnet and for unsecured remote shell protocols such as the Berkeley rlogin, rsh, and rexec protocols. Those protocols send information, notably passwords, in plaintext, rendering them susceptible to interception and disclosure using packet analysis. The encryption used by <strong>SSH</strong> is intended to provide confidentiality and integrity of data over an unsecured network, such as the Internet.</li></ol><h3 id="Usage-of-SSH-Command"><a href="#Usage-of-SSH-Command" class="headerlink" title="Usage of SSH Command"></a>Usage of SSH Command</h3><ol><li>Installation of <strong>SSH</strong> server: <code>sudo apt-get install openssh-server</code>.</li><li>Login command: <code>ssh username@ipaddress</code>.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operation Maintenance </tag>
            
            <tag> Linux Command </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced Knowledge of C Language</title>
      <link href="/2018/11/07/AdvancedKnowledgeofC/"/>
      <url>/2018/11/07/AdvancedKnowledgeofC/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Practice makes perfect. </p></blockquote><h2 id="Advanced-Knowledge-of-Function"><a href="#Advanced-Knowledge-of-Function" class="headerlink" title="Advanced Knowledge of Function"></a>Advanced Knowledge of Function</h2><h3 id="Memory-Management-in-Linux"><a href="#Memory-Management-in-Linux" class="headerlink" title="Memory Management in Linux"></a>Memory Management in Linux</h3><ol><li>Basic principles of von Neumann architecture<ul><li>The basic physical organization of a modern computer, based on the von Neumann architecture model, describes a design architecture for an electronic digital computer with these components<ul><li>A processing unit that contains an arithmetic logic unit and processor registers</li><li>A control unit that contains an instruction register and program counter</li><li>Memory that stores data and instructions</li><li>External mass storage</li><li>Input and output mechanisms<a id="more"></a></li></ul></li><li>Programs and data are arbitrarily stored into storage in binary code, whose locations are determined by their address.</li><li>The controller operates according to a sequence of instructions (programs) stored in memory and is controlled by a program counter (<strong>PC</strong>) to execute the instructions one by one.</li></ul></li><li>Running processes: code edit $\Rightarrow$ compile $\Rightarrow$ link $\Rightarrow$ load $\Rightarrow$ run<ul><li>Classification of linking: generate the logical address<ul><li>Static linking: use <code>gcc -static</code> to link object files into executable files and <code>ar -rc LibraryFile ObjectFile/SourceFile</code> to generate static library files whose prefix is <strong>lib</strong> and suffix is <strong>.a</strong>, and <code>ar -xv LibraryFile</code> to extract members from the archive.</li><li>Dynamic linking during loading or running: use <code>gcc -fPIC -shared ObjectFile/SourceFile -o LibraryFile</code> to generate dynamic library files whose prefix is <strong>lib</strong> and suffix is <strong>.so</strong>.</li></ul></li><li>Classification of loading: generate the physical address<ul><li>Absolute loading: only used in a single batch program environment.</li><li>Static relocation and dynamic relocation: usually used in the multichannel batch processing system, and the former happens during loading and the latter during running. And we can use <code>ldconfig Directory</code> to create the necessary links and cache to the most recent shared libraries found in the directories specified on the command line and use <code>ldd ExecutableFile</code> to print the shared objects (shared libraries) required by each program or shared object specified on the command line.</li></ul></li></ul></li><li>Virtual memory: <ul><li>The system allocates a virtual memory area to make processes independent with virtual addresses. The computer’s operating system, using a combination of hardware and software, maps memory addresses used by a program, called <em>virtual addresses</em>, into <em>physical addresses</em> in computer memory. Main storage, as seen by a process or task, appears as a contiguous address space or collection of contiguous segments. The operating system manages virtual address spaces and the assignment of real memory to virtual memory. Address translation hardware in the <strong>CPU</strong>, often referred to as a memory management unit or <strong>MMU</strong>, automatically translates virtual addresses to physical addresses. Software within the operating system may extend these capabilities to provide a virtual address space that can exceed the capacity of real memory and thus reference more memory than is physically present in the computer.</li><li><code>/proc/cpuinfo</code>: a collection of <strong>CPU</strong> and system architecture dependent items, for each supported architecture a different list. A 64-bit computers allocate 48 bits of virtual memory space (50% user-space: <code>[ 0x0000000000000000~0x00007FFFFFFFFFFF ]</code> and 50 % kernel-space: <code>[ 0xFFFF800000000000~ 0xFFFFFFFFFFFFFFFF ]</code>).</li><li><code>/proc/meminfo</code>: report statistics about memory usage on the system.</li><li><code>/proc/[pid]/maps</code>: a file containing the currently mapped memory regions and their access permissions.<ul><li><code>vsyscall</code>: virtual system call</li><li><code>vdso</code>: virtual dynamically linked shared object</li><li><code>stack</code>: the initial process’s (also known as the main thread’s) stack<ul><li>Local variable</li><li>Function parameter</li><li>Function return address</li></ul></li><li><code>xxx.so</code>: shared memory-mapped area</li><li><code>heap</code>: the process’s heap<ul><li>Dynamic memory allocation, like <code>malloc</code> and <code>realloc</code></li></ul></li><li><code>data segment</code>: static storage area (global variable and static variable) and constant area </li><li><code>code segment</code>: code area</li></ul></li><li>Segment-page memory management mechanism<ul><li>The virtual address contains segment number, page number and page offset.</li><li>The dynamic mapping between virtual addresses and physical addresses.</li><li><code>getconf PAGE_SIZE</code>: view size of a page</li></ul></li></ul></li><li>Common function in memory management:<ul><li><code>void *memset(void *s, int c, size_t n);</code>: fill the first <em>n</em> bytes of the memory area pointed to by <em>s</em> with the constant byte <em>c</em> and return a pointer to the memory area <em>s</em>.</li><li><code>void *memcpy(void *dest, const void *src, size_t n);</code>: copy <em>n</em> bytes from memory area <em>src</em> to memory area <em>dest</em>. The memory areas must not overlap. Please use <u>memmove</u>() if the memory areas do overlap and the function returns a pointer to <em>dest</em>.</li></ul></li></ol><h3 id="Scope-and-Storage-Type"><a href="#Scope-and-Storage-Type" class="headerlink" title="Scope and Storage Type"></a>Scope and Storage Type</h3><ol><li><p>Classification of scope</p><ul><li><p><code>global variable</code>: a variable with global scope, meaning that it is visible (hence accessible) throughout the program, unless shadowed. </p></li><li><p><code>local variable</code>:  a variable that is given local scope. Local variable references in the function or block in which it is declared override the same variable name in the larger scope.</p></li></ul></li><li>Storage type and link attribute of a variable:<ul><li><code>auto---none</code>: local variables are valid in a function during a period of the function calling and not initialized by default, generating random values. </li><li><code>static---internal</code>: static variables are always valid in a local area (one function or one source file) and live during the whole program execution. It is initialized by default once.</li><li><code>extern(global)---external</code>: its scope and life cycle are the whole programs, and it is initialized by default once.</li><li><code>register</code>: auto local variable is stored in the <strong>CPU</strong> register, accessed faster than memory and not initialized by default.</li></ul></li><li>Internal and external function<ul><li>Internal function: <code>static TataType FunctionName(FormalParameterList);</code>, only called in local source file.</li><li>External function: <code>(extern) TataType FunctionName(FormalParameterList);</code>, able to be called by other source file.</li></ul></li><li>Usage of <code>extern</code><ul><li>Declare/quote an external variable to expand the scope of the external variable.<ul><li>Declare external variable in a source file: to use the variable in the same file before the definition .</li><li>Quote external variable in multiple source files: to use the variable in the other file .</li></ul></li></ul></li></ol><h3 id="Function-Calling"><a href="#Function-Calling" class="headerlink" title="Function Calling"></a>Function Calling</h3><ol><li><p>Calling process of function is an operation of the stack space and we use the stack space to store the information about the called function.</p><ul><li>Establish stack space of the called function</li><li>Protect the running state and result address of the calling function</li><li>Pass the value of an argument to a procedure</li><li>Execute the statement in the called function body</li><li>Transfer control or return value to the calling function</li><li>Free the stack space of the called function</li></ul></li><li><p>Recursion</p><ul><li><p>Concept of recursion: most computer programming languages support recursion by allowing a function to call itself from within its own code. Some functional programming languages do not define any looping constructs but rely solely on recursion to repeatedly call code.</p></li><li><p>Feature:</p><ul><li>There are constraints and the recursion does not continue when the constraints are met.</li><li>Each recursive call gets closer and closer to the constraint.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// converts a decimal integer to a character and outputs it</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binary_to_ascii</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> temp;</span><br><span class="line">    temp = value / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (temp)</span><br><span class="line">        binary_to_ascii(temp);</span><br><span class="line">    <span class="built_in">putchar</span>(value % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input a number:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;number);</span><br><span class="line">    binary_to_ascii(number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><pre><code> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implement fibonacci</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> fibonacci(n - <span class="number">2</span>) + fibonacci(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input a number:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, fibonacci(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="Function-Pointer"><a href="#Function-Pointer" class="headerlink" title="Function Pointer"></a>Function Pointer</h3><ol><li><p>Concept of function pointer:  a pointer that points to a function.</p></li><li><p>Format of function pointer</p><ul><li><p>Definition: <code>DataType (*FunctionPointerName)(FormalParameterList);</code></p></li><li><p>Initialization: <code>FunctionPointerName = FunctionName;</code></p></li><li><p>Calling: <code>FunctionPointerName(ActualParameterList);</code> or  <code>(*FunctionPointerName)(ActualParameterList);</code></p></li></ul></li><li><p>Callback function</p><ul><li><p>Concept: a function called through function pointer</p></li><li><p>Instead of being called directly by the implementer of the function, a callback function is called by another party when a particular event or condition occurs and is used to respond to that event or condition.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use callback functions to call different sorting algorithms to sort array elements</span></span><br><span class="line"><span class="comment">//src/callback_sort_test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"callback_sort.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_data</span><span class="params">(<span class="keyword">int</span>* p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, p + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_data</span><span class="params">(<span class="keyword">int</span>* p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, *(p + i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, choose = <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"0:bubble_sort\n1:select_sort\nWhich sorting method would you like to</span></span><br><span class="line"><span class="string"> test:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;choose);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"How many numbers would you like to input:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> *data = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(n * siz**EOF**(<span class="keyword">int</span>));</span><br><span class="line">    init_data(data, n);</span><br><span class="line">    <span class="keyword">if</span>(choose==<span class="number">0</span>)</span><br><span class="line">    data_sort(data, n, bubble_sort, out_data);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        data_sort(data, n, select_sort, out_data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//include/callback_sort.h</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">data_sort</span><span class="params">(<span class="keyword">int</span>*, <span class="keyword">int</span>, <span class="keyword">void</span> (*)(<span class="keyword">int</span>*, <span class="keyword">int</span>), <span class="keyword">void</span> (*)(<span class="keyword">int</span>*, <span class="keyword">int</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//src/callback_sort.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span>* p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(p + j - <span class="number">1</span>) &gt; *(p + j)) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = *(p + j);</span><br><span class="line">                *(p + j) = *(p + j - <span class="number">1</span>);</span><br><span class="line">                *(p + j - <span class="number">1</span>) = temp;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span>* p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(p + j) &lt; *(p + min))</span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = *(p + min);</span><br><span class="line">            *(p + min) = *(p + i);</span><br><span class="line">            *(p + i) = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_sort</span><span class="params">(<span class="keyword">int</span>* p, <span class="keyword">int</span> n, <span class="keyword">void</span> (*sort)(<span class="keyword">int</span>*, <span class="keyword">int</span>), <span class="keyword">void</span> (*out)(<span class="keyword">int</span>*, <span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(p, n);</span><br><span class="line">    out(p, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use function pointer array to realize calculator function</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add</span><span class="params">(<span class="keyword">float</span> i, <span class="keyword">float</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">sub</span><span class="params">(<span class="keyword">float</span> i, <span class="keyword">float</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i - j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">mul</span><span class="params">(<span class="keyword">float</span> i, <span class="keyword">float</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i * j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">div</span><span class="params">(<span class="keyword">float</span> i, <span class="keyword">float</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i / j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_menu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"********************************\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1:add two numbers\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"2:sub two numbers\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"3:mul two numbers\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"4:div two numbers\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0:quit\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">float</span> (*fun_array[])(<span class="keyword">float</span>, <span class="keyword">float</span>) = &#123; add, sub, mul, div &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cmd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        show_menu();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cmd);</span><br><span class="line">        <span class="keyword">if</span> (!cmd)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Please input number1 and number2:"</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;i, &amp;j);</span><br><span class="line">            <span class="keyword">float</span> res = (**(fun_array + cmd - <span class="number">1</span>))(i, j);</span><br><span class="line">            <span class="comment">// float res = fun_array[cmd-1](i, j);</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Result:%g\n"</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="Variable-Argument-List"><a href="#Variable-Argument-List" class="headerlink" title="Variable Argument List"></a>Variable Argument List</h3><ol><li><p>Concept of the variable argument list: the numbers of function arguments are variable, such as this function prototype: <code>int scanf(const char *format, ...);</code>.</p></li><li><p>Usage of variable argument list: three macros (<strong>va_start</strong>, <strong>va_arg</strong>, <strong>va_end</strong>) and a data type (<strong>va_list</strong>).</p><ul><li><p><code>void va_start(va_list ap, last);</code>: initialize <em>ap</em> for subsequent use by <u>va_arg</u>() and <u>va_end</u>(), and must be called first. The argument <em>last</em> is the name of the last argument before the  variable argument list, that is, the last argument of which the calling function knows the type. Because the address of this argument may  be  used  in  the  <u>va_start</u>() macro,  it should not be declared as a register variable, or as a function or an array type.</p></li><li><p><code>type va_arg(va_list ap, type);</code>: expand to an expression that has the type and value of  the  next  argument in the call.  The argument <em>ap</em> is the <u>va_list</u> <em>ap</em> initialized by <u>va_start</u>().  Each call to <u>va_arg</u>() modifies <em>ap</em>  so  that the  next  call returns the next argument.  The argument <em>type</em> is a type name specified so that the type of a pointer to an object that has  the specified type can be obtained simply by adding a <em> to </em>type<em>. The  first use of the <u>va_arg</u>() macro after that of the <u>va_start</u>() macro returns the argument after </em>last<em>.   Successive  invocations  return  the values of the remaining arguments. If  there  is  no  next argument, or if </em>type<em> is not compatible with the type of the actual next argument (as promoted according to the  default argument promotions), random errors will occur. If </em>ap<em> is passed to a function that uses <u>va_arg</u>(<u>ap, type</u>), then the value of </em>ap* is undefined after the return of that function.   </p></li><li><p><code>void va_end(va_list ap);</code>: be matched by a corresponding  invocation of <u>va_end</u>() in the same function.  After the call <u>va_end</u>(<u>ap</u>) the variable <em>ap</em> is undefined.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use the variable parameter list to calculate the average value of a group of Numbers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span> n_value, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list var_arg;</span><br><span class="line">    <span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">    va_start(var_arg, n_value);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; n_value; count++) &#123;</span><br><span class="line">        sum += va_arg(var_arg, <span class="keyword">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(var_arg);</span><br><span class="line">    <span class="keyword">return</span> sum / n_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> aver = average(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"aver: %g.\n"</span>, aver);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Basic-Knowledge-of-String"><a href="#Basic-Knowledge-of-String" class="headerlink" title="Basic Knowledge of String"></a>Basic Knowledge of String</h2><h3 id="Character-Array"><a href="#Character-Array" class="headerlink" title="Character Array"></a>Character Array</h3><ol><li>Basic concept: a character array is an array of characters and a string is any sequence of characters enclosed in double quotation marks.</li><li><p>Initialization of character array: <code>char ArrayName[] = { CharSequence };</code>. When we initialize character array in this way, <code>&#39;\0&#39;</code> is supposed to be used to end the array. </p><ul><li><code>char array[] = {&#39;Y&#39;,&#39;o&#39;,&#39;u&#39;,&#39;t&#39;,&#39;h&#39;,&#39;F&#39;, &#39;a&#39;, &#39;i&#39;, &#39;t&#39;,&#39;h&#39;, &#39;\0&#39;}</code> or <code>{&quot;YouthFaith&quot;}</code> or <code>&quot;YouthFaith&quot;;</code> and the length is 10 while the size is 11 bytes.</li></ul></li><li><p>Input and output of character array once</p><ul><li><code>scanf(&quot;%s&quot;, ArrayName);</code></li><li><code>printf(&quot;%s&quot;, ArrayName);</code></li></ul></li><li><p>Pointer to string: <code>char *PointerName = &quot; StringConstant &quot;;</code> and <strong>StringConstant</strong> which can’t be modified but can be read, is stored into constants area in a data segment.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculate the average length of words in a sentence</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> letter = <span class="number">0</span>, word = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">30</span>] = <span class="string">"\0"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input a sentence:"</span>);</span><br><span class="line">    fgets(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>), <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(<span class="built_in">array</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'\n'</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">' '</span> || ch == <span class="string">'\t'</span>) &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!flag &amp;&amp; ch != <span class="string">' '</span> &amp;&amp; ch != <span class="string">'\t'</span>) &#123;</span><br><span class="line">            word++;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="string">' '</span> &amp;&amp; ch != <span class="string">'\t'</span>)</span><br><span class="line">            letter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Average word length:%g.\n"</span>, (<span class="keyword">float</span>)letter / word);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The common system functions about dealing with string</p><ul><li><code>char *gets(char *s);</code>: read a line from <em>stdin</em> into the buffer pointed to by <em>s</em> until either a terminating newline or <strong>EOF</strong>, which it replaces with a null byte (<strong>‘\0’</strong>). It return s on success, and <strong>NULL</strong> on error or when end of file occurs while no characters have been read. However, given the lack of buffer overrun checking, there can be no guarantees that the function will even return.</li><li><code>int puts(const char *s);</code>: write the string <em>s</em> and a trailing newline to <em>stdout</em>. It returns a nonnegative number on success, or <strong>EOF</strong> on error.</li><li><code>size_t strlen(const char *s);</code> calculates the length of the string pointed to by <em>s</em>, excluding the terminating null byte (<strong>‘\0</strong>‘). It returns the number of characters in the string pointed  to  by  <em>s</em>.</li><li><code>char *strcpy(char *dest, const char *src);</code> copies the string pointed to by <em>src</em>, including the terminating null byte (<strong>‘\0</strong>‘), to the buffer pointed to by <em>dest</em>. It returns a pointer to the destination string <em>dest</em>.</li><li><code>char *strncpy(char *dest, const char *src, size_t n);</code> is similar to <em>strcpy</em>, except that at most n bytes of <em>src</em> are copied. It returns a pointer to the destination string <em>dest</em>. </li><li><code>char *strcat(char *dest, const char *src);</code> appends the <em>src</em> string to the <code>dest</code> string, overwriting the terminating null byte (<strong>‘\0</strong>‘) at the end of <em>dest</em>, and then adds a terminating null byte. It returns a pointer to the resulting string <em>dest</em>.</li><li><code>char *strncat(char *dest, const char *src, size_t n);</code> is similar to <em>strcat</em> except that it will use at most n bytes from <em>src</em> and <em>src</em> does not need to be null-terminated if it contains n or more bytes. It returns a pointer to the resulting string <em>dest</em>.</li><li><code>int strcmp(const char *s1, const char *s2);</code> compares the two strings <em>s1</em> and <em>s2</em> according to ASCII. It returns an  integer  less  than,  equal  to,  or greater than zero if <em>s1</em> (or the first n bytes thereof) is found, respectively, to be less than, to match, or be greater than <em>s2</em>.</li><li><code>int strncmp(const char *s1, const char *s2, size_t n);</code> is similar to <em>strcmp</em>, except it compares only the first (at most) n bytes of <em>s1</em> and <em>s2</em>. It returns an  integer  less  than,  equal  to,  or greater than zero if <em>s1</em> (or the first n bytes thereof) is found, respectively, to be less than, to match, or be greater than <em>s2</em>.</li><li><code>char *strtok(char *str, const char *delim);</code> breaks a string into a sequence of zero or more nonempty tokens. It returns a pointer to the next token, or <strong>NULL</strong> if there are no more tokens.</li><li><code>char *strchr(const char *s, int c);</code> returns a pointer to the first occurrence of the character <em>c</em> in the string <em>s</em>. It returns a pointer to the matched character or <strong>NULL</strong> if the character is not found.  The terminating null byte is considered part of the  string,  so that if <em>c</em> is specified as <strong>‘\0’</strong>, these functions return a pointer to the terminator.</li><li><code>char *strrchr(const char *s, int c);</code> returns a pointer to the last occurrence of the character <em>c</em> in the string <em>s</em>. It returns a pointer to the matched character or <strong>NULL</strong> if the character is not found.  The terminating null byte is considered part of the  string,  so that if <em>c</em> is specified as <strong>‘\0’</strong>, these functions return a pointer to the terminator.</li></ul></li></ol><h2 id="Standard-Library-Functions"><a href="#Standard-Library-Functions" class="headerlink" title="Standard Library Functions"></a>Standard Library Functions</h2><h3 id="Common-Functions-in-stdlib-h"><a href="#Common-Functions-in-stdlib-h" class="headerlink" title="Common Functions in stdlib.h"></a>Common Functions in stdlib.h</h3><ol><li><code>int abs(int j);</code> and <code>long int labs(long int j);</code></li><li><code>int rand(void);</code> and <code>void srand(unsigned int seed);</code></li><li><code>int atoi(const char *nptr);</code> and <code>long atol(const char *nptr);</code></li><li><code>double atof(const char *nptr);</code></li></ol><h3 id="Common-Functions-in-math-h"><a href="#Common-Functions-in-math-h" class="headerlink" title="Common Functions in math.h"></a>Common Functions in math.h</h3><ol><li><code>double sin(double x);</code></li><li><code>double cos(double x);</code></li><li><code>double tan(double x);</code></li><li><code>double exp(double x);</code></li><li><code>double pow(double x, double y);</code></li></ol><h3 id="Common-Functions-in-time-h"><a href="#Common-Functions-in-time-h" class="headerlink" title="Common Functions in time.h"></a>Common Functions in time.h</h3><ol><li><p><code>time_t time(time_t *tloc);</code></p></li><li><p><code>char *ctime(const time_t *timep);</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implement the timer</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage:%s &lt;number&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> duration = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (duration &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Duration error\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">time_t</span> start, current;</span><br><span class="line">    time(&amp;start);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Start time:%s"</span>, ctime(&amp;start));</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        time(&amp;current);</span><br><span class="line">    &#125; <span class="keyword">while</span> ((current - start) != duration);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Current time:%s"</span>, ctime(&amp;current));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Structure-and-Union"><a href="#Structure-and-Union" class="headerlink" title="Structure and Union"></a>Structure and Union</h2><h3 id="What-is-Structure"><a href="#What-is-Structure" class="headerlink" title="What is Structure"></a>What is Structure</h3><ol><li><p>Concept of structure: a collection of data of the same or different types.</p></li><li><p>Declaration of structure: <code>struct StructName{ MemberList };</code> The system doesn’t allocate real memory at the time of declaration.</p></li><li><p>Definition of structure:</p><ul><li><code>struct StructName VariableName1, ... ,VariableNamen;</code>.</li><li><code>struct [StructName] { MemberList } VariableName1, ... ,VariableNamen;</code>.</li></ul></li><li><p>Initialization of structure</p><ul><li><code>struct StructName VariableNamen = { MemberValueList }, ... ;</code>.</li><li><code>struct [StructName] { MemberList } VariableNamen = { MemberValueList }, ... ;</code>.</li></ul></li><li><p>Access of structure member</p><ul><li>For structure variable: <code>StructName.MemberName</code>.</li><li>For structure pointer: <code>StructPointer-&gt;MemberName</code> or <code>(*StructPointer)-&gt;MemberName</code>.</li><li>Specially, structure member can be a structure pointer to itself for chain table and structure declaration can be incomplete to make different structures dependent on each other.</li></ul></li><li><p>Assignment of structure: <code>StructVariableName = AnotherStructVariableName;</code> or</p><p> <code>StructVariableName.MemberName = VariableValue;</code>.</p></li><li><p>Nest of structure: <code>struct [StructName] { ... struct StructName VariableName ... };</code>.</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implement a clock</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> hour;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">int</span> sec;</span><br><span class="line">&#125; Clock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> start, current;</span><br><span class="line">    time(&amp;start);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        time(&amp;current);</span><br><span class="line">    &#125; <span class="keyword">while</span> ((current - start) != <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(Clock* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;sec++;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;sec == <span class="number">60</span>) &#123;</span><br><span class="line">        p-&gt;sec = <span class="number">0</span>;</span><br><span class="line">        p-&gt;min++;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;min == <span class="number">60</span>) &#123;</span><br><span class="line">            p-&gt;min = <span class="number">0</span>;</span><br><span class="line">            p-&gt;hour++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(Clock* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">"clear"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d\n"</span>, p-&gt;hour, p-&gt;min, p-&gt;sec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Clock c = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> sec = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please enter how much time do you want to time(s):"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;sec);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sec; i++) &#123;</span><br><span class="line">        delay();</span><br><span class="line">        increment(&amp;c);</span><br><span class="line">        show(&amp;c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Byte-Alignment"><a href="#Byte-Alignment" class="headerlink" title="Byte Alignment"></a>Byte Alignment</h3><ol><li>Concept of byte alignment: The various types of data are arranged according to certain rules, rather than being stored sequentially one by one.</li><li>Specifies the number of byte alignments: <code>#pragma pack(Bytes)</code> and <code>#pragma pack()</code>.</li><li>Rules: <ul><li>Basic data types are byte-aligned to their size.</li><li>Structure data types are byte-aligned to the maximum size of its member variables.</li><li>Especially, valid alignment value is the smaller one between self-defined and original ones. So, Members of a structure are supposed to be defined by type from small to large.</li></ul></li><li>Bitfield: a member variable can be a bit in a structure.<ul><li>Definition of bit field: <code>DataType [BitFieldName]:Length</code>.</li><li>Thereamong, <code>Length</code> can’t exceed the size of <code>DataType</code>.</li></ul></li></ol><h3 id="What-is-Union"><a href="#What-is-Union" class="headerlink" title="What is Union"></a>What is Union</h3><ol><li>Concept of the union: Different types of variables are stored in the same segment of memory.</li><li>Declaration of union: <code>union UnionName { UnionMemberList };</code>.</li><li>Initialization of union: must be the first member variable.</li></ol><h3 id="Difference-Between-Typedef-and-Define"><a href="#Difference-Between-Typedef-and-Define" class="headerlink" title="Difference Between Typedef and Define"></a>Difference Between Typedef and Define</h3><ol><li>Usage of typedef<ul><li>Function time: compile.</li><li>Define another name for a data type: <code>typedef OldDataType NewDataType;</code>.</li><li>Define a new simple alias for a complex declaration: <code>typedef DataTypeExpressionWithAlias;</code>. For example, <code>void (*a)(void);</code> $\Rightarrow$ <code>typedef void (*Alias)(void); Alias a;</code>.</li></ul></li><li>Usage of define<ul><li>Function time: preprocess.</li><li>Replace old string with new string: <code>#define NewString OldString</code>.</li></ul></li></ol><h2 id="Advanced-Knowledge-of-Pointer"><a href="#Advanced-Knowledge-of-Pointer" class="headerlink" title="Advanced Knowledge of Pointer"></a>Advanced Knowledge of Pointer</h2><h3 id="Untyped-Pointer"><a href="#Untyped-Pointer" class="headerlink" title="Untyped Pointer"></a>Untyped Pointer</h3><ol><li>Concept of untyped pointer: able to point to any variable in any type.</li><li>Definition of untyped pointer: <code>void *PointerName</code>.</li><li>Usage of untyped pointer: <code>(DataType*)PointerName</code> If you want to get the value of the variable using an untyped pointer, you need to transform the untyped pointer to a typed pointer that matches the variable type.</li><li>Access to memory: <code>DataType *PointerName = (DataType*)MemoryAddress;</code>.</li></ol><h3 id="Two-dimensional-Array"><a href="#Two-dimensional-Array" class="headerlink" title="Two-dimensional Array"></a>Two-dimensional Array</h3><ol><li><p>Two-dimensional array address</p><ul><li><p>Row address: Subscript-th row address</p><ul><li><code>ArrayName + Subscript</code></li></ul></li><li><p>Column address: Subscript-th row first column address</p><ul><li><code>ArrayName[Subscript]</code> $\Rightarrow$ <code>*(ArrayName + Subsript)</code></li></ul></li><li><p>Element address:</p><ul><li><code>ArrayName[Row]+Column</code></li><li><code>*(ArrayName+Row)+Column</code></li><li><code>&amp;ArrayName[Row][Column]</code></li></ul></li><li><p>Element value:</p><ul><li><code>*(ArrayName[Row]+Column)</code></li><li><code>*(*(ArrayName+Row)+Column)</code></li><li><code>ArrayName[Row][Column]</code></li></ul></li><li><p>Specially, <code>*RowAddress</code> = <code>ColumnAddress</code>, <code>RowAddress</code> = <code>&amp;ColumnAddress</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usage of two-dimensional array address in function</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out1</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">3</span>], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*********out1*********\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out2</span><span class="params">(<span class="keyword">int</span>* p, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*********out2*********"</span>);</span><br><span class="line">    <span class="keyword">int</span>* s = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (s = p; s &lt; p + size; s++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s - p) % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, *s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out3</span><span class="params">(<span class="keyword">int</span> (*p)[<span class="number">3</span>], <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*********out3*********\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, *(*(p + i) + j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            *(*(arr + i) + j) = rand() % <span class="number">90</span> + <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out1(arr, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    out2(*arr, <span class="number">9</span>);</span><br><span class="line">    out3(arr, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="Pointer-Array"><a href="#Pointer-Array" class="headerlink" title="Pointer Array"></a>Pointer Array</h3><ol><li><p>Concept of pointer array: an array of pointer to other variables stored in other memory.</p></li><li><p>Definition of pointer array: <code>DataType *ArrayName[] = { PointerList };</code>.</p></li><li><p>A secondary pointer can be used to point to the first address of the pointer array.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input several student names from the keyboard and sort them</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 20</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outStudent</span><span class="params">(<span class="keyword">char</span>** p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s "</span>, *(p + i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortStudent</span><span class="params">(<span class="keyword">char</span>** p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(*(p + j), *(p + j - <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span>* temp = *(p + j);</span><br><span class="line">                *(p + j) = *(p + j - <span class="number">1</span>);</span><br><span class="line">                *(p + j - <span class="number">1</span>) = temp;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"How many students do you want to sort:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">char</span>** p = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*) * n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input their score one by one:"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> temp[MAX] = <span class="string">"\0"</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %s"</span>, temp);</span><br><span class="line">        *(p + i) = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (<span class="built_in">strlen</span>(temp) + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">strcpy</span>(*(p + i), temp);</span><br><span class="line">    &#125;</span><br><span class="line">    outStudent(p, n);</span><br><span class="line">    sortStudent(p, n);</span><br><span class="line">    outStudent(p, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Dynamic-Memory-Allocation"><a href="#Dynamic-Memory-Allocation" class="headerlink" title="Dynamic Memory Allocation"></a>Dynamic Memory Allocation</h2><h3 id="Memory-Allocation"><a href="#Memory-Allocation" class="headerlink" title="Memory Allocation"></a>Memory Allocation</h3><ol><li>Static storage area: Memory allocation has been finished after program compiling, like global variable and static variable.</li><li>Stack area: Storage cells of a local variable are created during function calling and they will be freed automatically as the function returns.</li><li>Heap area: Programmers can apply for any storage are in heap during runtime and free them manually with some functions like <code>malloc</code> or <code>realloc</code>.</li></ol><h3 id="Common-Functions"><a href="#Common-Functions" class="headerlink" title="Common Functions"></a>Common Functions</h3><ol><li><code>void *malloc(size_t size);</code>: allocates <em>size</em> bytes and returns a pointer to the allocated memory. The memory is not initialized.</li><li><code>void *calloc(size_t nmemb, size_t size);</code>: allocates memory for an array of <em>nmemb</em> elements of <em>size</em> bytes each and returns a pointer to the allocated memory. The memory is set to zero.</li><li><code>void *realloc(void *ptr, size_t size);</code>: changes the size of the memory block pointed to by <em>ptr</em> to <em>size</em> bytes. The contents will be unchanged in the range from the start of the region up to the minimum of the old and new sizes. If the new size is larger than the old size, the added memory will not be initialized. If <em>ptr</em> is <strong>NULL</strong>, then the call is equivalent to <u>malloc</u>(size), for all values of size; if the size is equal to zero, and <em>ptr</em> is not <strong>NULL</strong>, then the call is equivalent to <u>free</u>(ptr).</li><li><code>void free(void *ptr);</code>: frees the memory space pointed to by <em>ptr</em>, which must have been returned by a previous call to <u>malloc</u>(), <u>calloc</u>(), or <u>realloc</u>().</li></ol><h2 id="Preprocess"><a href="#Preprocess" class="headerlink" title="Preprocess"></a>Preprocess</h2><h3 id="What-is-Preprocess"><a href="#What-is-Preprocess" class="headerlink" title="What is Preprocess"></a>What is Preprocess</h3><ul><li>Concept of preprocessing: Preprocessing generally is considered as the process of generating binary code before the source code of a program is translated into object code. Typically, the program source code text is processed by a preprocessor, and the result is further compiled by the compiler core. This process does not parse the program’s source code, but it splits or divides the source code into specific units —- preprocessing tokens, to support language features. It takes lines beginning with ‘#’ as directives. Because it knows nothing about the underlying language, its use has been criticized and many of its features built directly into other languages. For example, macros replaced with aggressive inlining and templates, includes with compile-time imports (this requires the preservation of type information in the object code, making this feature impossible to retrofit into a language); conditional compilation is effectively accomplished with <code>if-then-else</code> and dead code elimination in some languages. However, a key point to remember is that all preprocessor directives should start on a new line.</li></ul><h3 id="Macro-Substitution"><a href="#Macro-Substitution" class="headerlink" title="Macro Substitution"></a>Macro Substitution</h3><ol><li>Format of the macro: <code>#define NewString OldString</code>. <strong>NewString</strong> is replaced with <strong>OldString</strong> during preprocessing and it’s essentially a substitution of strings.</li><li>Predefined macro:<ul><li><code>__FILE__</code>: source file name</li><li><code>__LINE__</code>: line number during runtime</li><li><code>__DATE__</code>: a current day in the form —- <strong>month day year</strong></li><li><code>__TIME__</code>: current time in the form —- <strong>hour:minute:second</strong> </li><li><code>__func__</code>: current called function name</li></ul></li></ol><h3 id="Conditional-Compile"><a href="#Conditional-Compile" class="headerlink" title="Conditional Compile"></a>Conditional Compile</h3><ol><li><p>Concept of conditional compile: Normally, every line of code is compiled. However, sometimes for the consideration of program code optimization, we want to compile only part of the contents. At this time, we need to add conditions in the program and let the compiler compile the code that meets the conditions, and discard the code that does not meet the conditions.</p></li><li><p>Usage of conditional compile: <code>#if</code>, <code>#elif</code>, <code>#else</code>, <code>#ifndef</code>, <code>#ifdef</code>, <code>#define</code>, <code>#endif</code>, <code>#error</code>, <code>#line</code>, <code>#pragma</code></p></li></ol><h3 id="File-Including"><a href="#File-Including" class="headerlink" title="File Including"></a>File Including</h3><ol><li><p>Header file references are defined in double quotation marks and system header file references in angle brackets.</p></li><li><p>Lookup order of header files: the directory where the source files have located $\rightarrow$ the directory specified by <code>-I</code> $\rightarrow$ system environment path</p></li><li><p>Usually, conditional compile is used to prevent multiple inclusions, like <code>#ifndef ... #define ... #endif</code>.</p></li></ol><h2 id="File-Operation"><a href="#File-Operation" class="headerlink" title="File Operation"></a>File Operation</h2><h3 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h3><ol><li><p>Concept of file: a collection of information stored in a computer’s hard disk. From the user’s point of view, files can be divided into ordinary files and device files. According to the way of file encoding, files are divided into text files and binary files.</p></li><li><p>Classification of the file system</p><ul><li>Buffered file system: The system automatically creates a buffer in the memory area for each file in use. Either reading data from disk to memory or writing data from memory to disk needs to go through a buffer. Generally, data is sent to a designated location only when the buffer is full. And a buffered file system is called standard input and output.</li><li>Unbuffered file system: Buffers are not automatically set by the system, but by the user, as needed. And the unbuffered file system is called system input and output.</li></ul></li><li><p>Three standard streams</p><ul><li><code>stdin(0)</code>: standard input keyboard</li><li><code>stdout(1)</code>: standard output screen</li><li><code>stderr(2)</code>: standard output screen</li><li><code>/dev/null</code>: a special device file, called black hole, discards all written data</li></ul></li></ol><h3 id="File-Pointer"><a href="#File-Pointer" class="headerlink" title="File Pointer"></a>File Pointer</h3><ol><li><p>Definition of file pointer: <code>FILE *PointerName</code>. The system automatically creates a file type structure variable for it and return a pointer to it when we open a file. The program use this pointer to access file and get information. </p></li><li><p>Mode of file pointer: The argument mode points to a string beginning with one of th following sequences (possibly followed by additional characters, as described below).</p><ul><li><code>r</code>: open text file for reading. The stream is positioned at the beginning of the file.</li><li><code>w</code>: truncate a file to zero length or create text file for writing. The stream is positioned at the beginning of the file.</li><li><code>a</code>: open for appending (writing at end of file). The file is created if it does not exist. The stream is positioned at the end of the file.</li><li><code>+</code>: open for reading and writing.</li><li><code>b</code>: The mode string can also include the letter <strong>b</strong> either as the last character or as a character between the characters in any of the two-character strings described above. This is strictly for compatibility with <strong>C89</strong> and has no effect; the <strong>b</strong> is ignored on all <strong>POSIX</strong> conforming systems, including Linux. (Other systems may treat text files and binary files differently, and adding the <strong>b</strong> may be a good idea if you do <strong>I/O</strong> to a binary file and expect that your program may be ported to non-UNIX environments.)</li></ul></li><li><p>Common functions about file pointer</p><ul><li>Standard I/O function<ul><li><code>FILE *fopen(const char *pathname, const char *mode);</code>: open the file whose name is the string pointed to by <em>pathname</em> and associates a stream with it.  Upon  successful  completion  <u>fopen</u>(), <u>fdopen</u>() and <u>freopen</u>() return a <strong>FILE</strong> pointer. Otherwise, <strong>NULL</strong> is returned and <em>errno</em> is set to indicate the error.</li><li><code>int fclose(FILE *stream);</code>: flush the stream pointed to by <em>stream</em> (writing any buffered output data using fflush and closes the underlying file descriptor. Upon  successful completion, 0 is returned.  Otherwise, <strong>EOF</strong> is returned and <em>errno</em> is set to indicate the error.  In either case, any further  access  (including  another call to <u>fclose</u>()) to the stream results in undefined behavior.</li><li><code>long ftell(FILE *stream);</code>: obtain the current value of the file position indicator for the stream pointed to by <em>stream</em>. It returns  no  value.  Upon successful completion, it returns the current offset.  Otherwise,  -1 is returned and <em>errno</em> is set to indicate the error.</li><li><code>char *fgets(char *s, int size, FILE *stream);</code>: read in at most one less than <em>size</em> characters from <em>stream</em> and stores them into the buffer pointed to by <em>s</em>. Reading stops after an <strong>EOF</strong> or a newline. If a <strong>newline</strong> is read, it is stored into the buffer. A terminating null byte<strong>(‘\0’)</strong> is stored after the last character in the buffer. And it returns <strong>s</strong> on success, and <strong>NULL</strong> on error or when the end of file occurs while no characters have been read. It returns <em>s</em> on success, and <strong>NULL</strong> on error or when end of file occurs while  no characters have been read.</li><li><code>int fputs(const char *s, FILE *stream);</code>: write the string <em>s</em> to <em>stream</em>, without its terminating null byte<strong>(‘\0’)</strong>. And it returns a nonnegative number on success, or <strong>EOF</strong> on error.</li><li><code>int fscanf(FILE *stream, const char *format, ...);</code>: read input from the stream pointer <em>stream</em>. On success, it returns the number of input items successfully matched and assigned; this can be fewer than provided for, or even zero, in the event of an early matching failure. The value <strong>EOF</strong> is returned if the end of input is reached before either the first successful conversion or a matching failure occurs. <strong>EOF</strong> is also returned if a read error occurs, in which case the error indicator for the stream is set, and <em>errno</em> is set to indicate the error.</li><li><code>int fprintf(FILE *stream, const char *format, ...);</code>: output to a file descriptor <em>fd</em>, instead of to a stdio stream. Upon successful return, it returns the number of characters printed(excluding the null byte used to end output to strings) and If an output error is encountered, a negative value is returned.</li></ul></li><li>System I/O function<ul><li><code>int open(const char *pathname, int flags, mode_t mode);</code>: open the file specified by pathname and return a file descriptor, a small, nonnegative integer that is used in subsequent system calls to refer to the open file. The file descriptor returned by a successful call will be the lowest-numbered file descriptor not currently open for the process. The argument <em>flags</em> must include one of the following access modes: <strong>O_RDONLY</strong>, <strong>O_WRONLY</strong>, <strong>O_RDWR</strong>, <strong>O_APPEND</strong>, <strong>O_TRUNC</strong>, <strong>O_CREAT</strong> and <strong>O_EXCL</strong>. And the argument <strong>mode</strong> must be include one of the following access modes: <strong>S_IUSR</strong>, <strong>S_IWUSR</strong>, <strong>S_IXUSR</strong>, <strong>S_IRGRP</strong>, <strong>S_IWGRP</strong>, <strong>S_IXGRP</strong>, <strong>S_IROTH</strong>, <strong>S_IWOTH</strong> and <strong>S_IXOTH</strong>, or umask bit. It returns the new file descriptor, or -1 if an error occurred.</li><li><code>int close(int fd);</code>: close a file descriptor, so that it no longer refers to any file and may be reused and return zero on success. On error, -1 is returned, and <em>errno</em> is set appropriately.</li><li><code>ssize_t read(int fildes, void *buf, size_t nbyte);</code>: read <em>nbyte</em> bytes from the file associated with the open file descriptor, <em>fildes</em>, into the buffer pointed to by <em>buf</em>.  On  success,  the number of bytes read is returned (zero indicates end of file), and the file position is advanced by this number.  It is not an error if this number  is smaller  than  the  number  of  bytes requested; this may happen for example because fewer bytes are actually available right now (maybe because we were close to end-of- file,  or because we are reading from a pipe, or from a terminal), or because <u>read</u>() was interrupted by a signal. On error, -1 is returned, and <em>errno</em> is set appropriately.  In this case, it is  left unspecified whether the file position (if any) changes.</li><li><code>ssize_t write(int fildes, const void *buf, size_t nbyte);</code>: write <em>nbyte</em> bytes from the buffer pointed to by <em>buf</em> to the file associated with the open file descriptor, <em>fildes</em>. On  success,  the  number  of  bytes written is returned (zero indicates nothing was  written).  It is not an error if this number is smaller than the number of bytes requested;  this  may happen for example because the disk device was filled. On error, -1 is returned, and errno is set appropriately.</li></ul></li></ul></li><li><p>Input and output of binary file</p><ul><li><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</code>: read <em>nmemb</em> items of data, each <em>size</em> bytes long, from the stream, pointed to by <em>stream</em>, storing them at the location given by <em>ptr</em>. </li><li><code>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</code>: write <em>nmemb</em> items of data, each <em>size</em> bytes long, to the stream pointed to by <em>stream</em>, obtaining them from the location given by <em>ptr</em>.</li><li>On success they return the number of items read or written. This number equals the number of bytes transferred only when <em>size</em> is 1. If an error occurs, or the end of the file is reached, the return value is a short item count (or zero).</li></ul></li><li><p>Other functions in file operation</p><ul><li><p><code>int fseek(FILE *stream, long offset, int whence);</code>: set the file position indicator for the stream pointed to by <em>stream</em>. The new position, measured in bytes, is obtained by adding offset bytes to the position specified by <em>whence</em>. If <em>whence</em> is set to <strong>SEEK_SET</strong>, <strong>SEEK_CUR</strong>, or <strong>SEEK_END</strong>, the offset is relative to the start of the file, the current position indicator, or end-of-file, respectively. A successful call to the <code>fseek()</code> function clears the end-of-file indicator for the stream and undoes any effects of the <code>ungetc()</code> function on the same stream. Upon successful completion, it returns 0. Otherwise, -1 is returned and <em>errno</em> is set to indicate the error.</p></li><li><p><code>int fflush(FILE *stream);</code>: force a write of all user-space buffered data for the given output or update <em>stream</em> via the stream’s underlying write function. Upon successful completion 0 is returned. Otherwise, <strong>EOF</strong> is returned and <em>errno</em> is set to indicate the error.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// count the number of words in the file</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE_SPACE_OR (c == <span class="meta-string">' '</span> || c == <span class="meta-string">'\t'</span> || c == <span class="meta-string">'\n'</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE_SPACE_AND (c != <span class="meta-string">' '</span> &amp;&amp; c != <span class="meta-string">'\t'</span> &amp;&amp; c != <span class="meta-string">'\n'</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage:%s file\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>, word = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">    FILE* p = <span class="literal">NULL</span>;</span><br><span class="line">    p = fopen(argv[<span class="number">1</span>], <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open file error!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((c = fgetc(p)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (WHITE_SPACE_OR) &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!flag &amp;&amp; WHITE_SPACE_AND) &#123;</span><br><span class="line">            word++;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"total of word:%d\n"</span>, word);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C Language </tag>
            
            <tag> Advanced Knowledge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basic Knowledge of C Language</title>
      <link href="/2018/10/07/BasicKnowledgeofC/"/>
      <url>/2018/10/07/BasicKnowledgeofC/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>dog $\sim$ Sin dog</p></blockquote><h2 id="Introduction-of-C-Language"><a href="#Introduction-of-C-Language" class="headerlink" title="Introduction of C Language"></a>Introduction of C Language</h2><h3 id="Program-Algorithm-Data-Structure"><a href="#Program-Algorithm-Data-Structure" class="headerlink" title="Program = Algorithm + Data Structure"></a>Program = Algorithm + Data Structure</h3><ol><li>Concept of the program: as a translator between computer language and human language, it is a collection of instructions that performs a specific task when executed by a computer. Usually, A computer program is usually written by a computer programmer in a programming language. From the program in its human-readable form of source code, a compiler or assembler can derive machine code — a form consisting of instructions that the computer can directly execute. Alternatively, a computer program may be executed with the aid of an interpreter. A collection of computer programs, libraries, and related data are referred to as software. Computer programs may be categorized along functional lines, such as application software and system software. <a id="more"></a></li><li>Concept of the algorithm: the underlying method used for some calculation or manipulation is known as an algorithm. To be specific, it is an accurate and complete description of a solution to a problem. As an effective method, an algorithm can be expressed within a finite amount of space and time and in a well-defined formal language for calculating a function. Starting from an initial state and initial input (perhaps empty), the instructions describe a computation that, when executed, proceeds through a finite number of well-defined successive states, eventually producing “output” and terminating at a final ending state. The transition from one state to the next is not necessarily deterministic; some algorithms, known as randomized algorithms, incorporate random input.</li><li>Concept of the data structure: in computer science, it is a data organization, management, and storage format that enables efficient access and modification. More precisely, a data structure is a collection of data values, the relationships among them, and the functions or operations that can be applied to the data.</li></ol><h3 id="Development-of-Computer-Language"><a href="#Development-of-Computer-Language" class="headerlink" title="Development of Computer Language"></a>Development of Computer Language</h3><ol><li>Machine language: consist of binary instructions for ‘0’ and ‘1’. It can be executed directly by a computer’s central processing unit (<strong>CPU</strong>). Each instruction causes the <strong>CPU</strong> to perform a very specific task, such as a load, a store, a jump, or an <strong>ALU</strong> operation on one or more units of data in <strong>CPU</strong> registers or memory.</li><li>Assembly language: instructions described by mnemonic and it is any low-level programming language in which there is a very strong correspondence between the instructions in the language and the architecture’s machine code instructions.</li><li>High-level language: contain object-oriented or process-oriented languages. And <strong>C</strong> language, which belongs to process-oriented languages, is suitable for system-level development, but not application level.</li></ol><h3 id="The-First-C-Program"><a href="#The-First-C-Program" class="headerlink" title="The First C Program"></a>The First C Program</h3><ul><li><p>A “Hello, World!” program generally is a computer program that outputs or displays the message “Hello, World!”. Such a program is very simple in most programming languages, and is often used to illustrate the basic syntax of a programming language. It is often the first program written by people learning to code</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) Free Software Foundation, Inc.</span></span><br><span class="line"><span class="comment"> * File name: main.c</span></span><br><span class="line"><span class="comment"> * Author: YouthFaith</span></span><br><span class="line"><span class="comment"> * Version: 1.0.0</span></span><br><span class="line"><span class="comment"> * Date: 2018/10/07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Comment-in-C-Language"><a href="#Comment-in-C-Language" class="headerlink" title="Comment in C Language"></a>Comment in C Language</h3><ol><li><code>/* xxxxxx */</code>: multi-line comment.</li><li><code>//xxx</code>: single-line comment.</li><li>Usually used for<ul><li>Announcement for version or copyright.</li><li>Function description.</li><li>Prompts of important lines or paragraphs.</li></ul></li></ol><h3 id="Development-Process-of-C-Program"><a href="#Development-Process-of-C-Program" class="headerlink" title="Development Process of C Program"></a>Development Process of C Program</h3><ol><li>Requirements analysis: focus on the tasks that determine the needs or conditions to meet the new or altered product or project, taking account of the possibly conflicting requirements of the various stakeholders, analyzing, documenting, validating and managing software or system requirements.</li><li>Software design: the process by which an agent creates a specification of a software artifact, intended to accomplish goals, using a set of primitive components and subject to constraints. Software design may refer to either “all the activity involved in conceptualizing, framing, implementing, commissioning, and ultimately modifying complex systems” or “the activity following requirements specification and before programming, as … [in] a stylized software engineering process.”</li><li>Implement<ul><li>Write program code: generate source file with “.c “as file extension.</li><li>Compile source file: generate target file with “.o” as file extension.</li><li>Link object file: generate executable files.</li></ul></li><li>Testing: an investigation conducted to provide stakeholders with information about the quality of the software product or service under test. Software testing can also provide an objective, independent view of the software to allow the business to appreciate and understand the risks of software implementation. Test techniques include the process of executing a program or application with the intent of finding software bugs (errors or other defects), and verifying that the software product is fit for use.</li><li>Deployment: all of the activities that make a software system available for use.</li><li>Maintenance: the modification of a software product after delivery to correct faults, to improve performance or other attributes.</li></ol><h2 id="Primary-Data-Type"><a href="#Primary-Data-Type" class="headerlink" title="Primary Data Type"></a>Primary Data Type</h2><h3 id="Constants-and-Variables"><a href="#Constants-and-Variables" class="headerlink" title="Constants and Variables"></a>Constants and Variables</h3><ol><li>Constant: A variable whose value can not be changed during the execution and can be used directly without declaration.<ul><li>Contains direct constant (integer constant, float constant, character constant and string constant) and symbolic constant (use <strong>#define</strong> keyword to declare).</li><li>The function of symbolic constant<ul><li>Accurate Meaning.</li><li>One changes, all change.</li></ul></li><li>Specially, macro with parameters is just statement substitution in the preprocessing phase.</li></ul></li><li>Variable: A variable, whose value can be changed during the execution, represents a storage cell. One variable has one name and occupies certain storage unit in the memory.<ul><li>Must be used after being declared.</li><li>Declaration is classified into definitional declaration and referential declaration(use <strong>extern</strong> keyword to declare).</li></ul></li><li>The naming rule of identifier: consist of letters, numbers and underline. Specially it must start with letters or underline, and be case sensitive.</li><li>The declaration, initialization and definition of a variable<ul><li>Declaration: declare type and name to the compiler without allocating storage space (referential declaration). Format: <code>DataType VariableName;</code>.</li><li>Definition and initialization: declare type and name with allocating storage space. Format: <code>DataType VariableName = Value;</code>.</li></ul></li></ol><h3 id="Data-Type"><a href="#Data-Type" class="headerlink" title="Data Type"></a>Data Type</h3><ol><li>The primary data type is classified into: basic data type (<strong>int</strong>, <strong>float</strong>, <strong>char</strong> and <strong>enum</strong>), structure data type (<strong>array</strong>, <strong>struct</strong>, <strong>union</strong>), pointer data type (<strong>*</strong>) and generic data type (<strong>void</strong>).</li><li>We can use <strong>sizeof</strong> keyword to view the bytes the variable occupies in memory.</li><li><p>Integer (<strong>short</strong>, <strong>int</strong>, <strong>long</strong>): When the assignment is out of range, the assignment is restarted, such as 65536 in short is 0.</p><ul><li><p>Integers are stored in memory in the form of complemental code, such as the storage form of <code>int i = 10;</code> in memory is <code>[ 0000 0000 0000 0000 0000 0000 0000 1010 ]</code>(4B in total), and the storage form of <code>int i = -10;</code> in memory is <code>[ 1111 1111 1111 1111 1111 1111 1111 0110 ]</code>(4B in total).</p></li><li><p><strong>%d</strong> (decimal), <strong>%o</strong> (octal), <strong>%x</strong> (hexadecimal), <strong>%e</strong> (scientific notation), <strong>%f</strong> (float).</p></li><li><p>short (2B), unsigned short (2B), int (4B), unsigned (4B), long (8B), unsigned long (8B) —- based on a 64-bit computer as shown in <strong>limits.h</strong> header file.</p></li></ul></li><li>Character (char): The character type is enclosed in single quotation marks, corresponding to the ASCII (1B in total);<ul><li>In computing, an escape character is a character which invokes an alternative interpretation on subsequent characters in a character sequence. An escape character is a particular case of meta-characters. Generally, the judgment of whether something is an escape character or not depends on context. In many programming languages, an escape character also forms some escape sequences which are referred to control characters. For example, line break has an escape sequence of <strong>\n</strong>.</li><li>String variable: enclosed in double quotation marks, and is able to contain one or more characters. We use a character array to store a string variable with <strong>\0</strong> ending tag.</li><li>String array: <code>char StringName[] = &quot;String\0&quot;;</code>.</li></ul></li><li>Float and double type<ul><li>Float constant: decimal form and exponential form.</li><li>The way to store: <strong>IEEE</strong> <strong>754</strong>. It is divided into: <strong>S</strong> (sign), <strong>E</strong> (exponent-marker), <strong>M</strong> (mantissa), and exponent-marker is represented by frame shift with 127 offset. </li><li>Float is 32-bit and double is 64-bit.</li></ul></li><li>Enumerated type<ul><li>The declaration format: <code>enum EnumName{Value1, Value2, ..., Valuen};</code>.</li><li>The definition format<ul><li><code>enum EnumName VariableName;</code>.</li><li><code>enum EnumName{Value1, Value2, ..., Valuen} VariableName;</code>.</li><li><code>enum {Value1, Value2, ..., Valuen} VariableName;</code>.</li></ul></li><li>Specially, enumerated type belongs to integer type, and its value is defined as 0, 1, 2, …, n.</li></ul></li></ol><h3 id="Formatted-Input-Output-Function"><a href="#Formatted-Input-Output-Function" class="headerlink" title="Formatted Input/Output Function"></a>Formatted Input/Output Function</h3><ol><li>Buffer mechanism<ul><li>The three types of buffering available are unbuffered, block buffered, and line buffered. When an output stream is unbuffered, information appears on the destination file or terminal as soon as written. When it is block buffered many characters are saved up and written as a block. When it is line buffered characters are saved up until a newline is output or input is read from any stream attached to a terminal device (typically <strong>stdin</strong>). The function <strong>fflush</strong> may be used to force the block out early or wait until the program ends. Of course, when the buffer is full, the output is automatically made.</li><li>Normally all files are block buffered and we can use <strong>fclose</strong> to force the block out. If a stream refers to a terminal (as <strong>stdout</strong> normally does), it is line buffered. And when it encounters <strong>\n</strong>, it will automatically output. The standard error stream <strong>stderr</strong> is always unbuffered by default. </li></ul></li><li><p>Standard input/output function</p><ul><li><p>Formatted output (<strong>*</strong> is used to define format) and formatted input (<strong>*</strong> is used to delay)</p><ul><li><p><code>int printf(const char *format, ...);</code> $\Rightarrow$ <code>printf(&quot;%[mark][output minimun width][.accuracy][long tag]type&quot;, VariableName);</code>.</p></li><li><p><code>int scanf(const char *format, ...);</code> $\Rightarrow$ <code>scanf(&quot;%[mark][input minimun width][long tag]type&quot;, VariableAddress);</code>.</p></li><li><p>Mark: <strong>-</strong> (align left, whitespace right), <strong>+</strong> (output signs), <strong>blank space</strong> (positive numbers with spaces, negative numbers with minus signs), <strong>#</strong> (formalize octal and hexadecimal numbers).</p></li><li><p>Long tag: <strong>h</strong> represents short integers and <strong>l</strong> represents long integers.</p></li><li><p>Type: <strong>d</strong> (decimal), <strong>o</strong> (octal), <strong>x</strong> (hexadecimal), <strong>f</strong> (float and double), <strong>e</strong> (scientific notation), <strong>c</strong> (char), <strong>s</strong> (string), <strong>p</strong> (address or pointer variable), <strong>g</strong> (only show significant digit).</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculate the area of a circle</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input a number for the radius of a circle:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The area of circle is: %.2f.\n"</span>, M_PI * i * i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><ol><li>Common functions about input and output<ul><li><code>int sscanf(const char *str, const char *format, ...);</code>: read its input from the character string pointed to by <em>str</em>. On success, it returns the number of input items successfully matched and assigned; this can be fewer than provided for, or even zero, in the event of an early matching failure. The value <strong>EOF</strong> is returned if the end of input is reached before either the first successful conversion or a matching failure occurs. <strong>EOF</strong> is also returned if a read error occurs, in which case the error indicator for the stream is set, and <em>errno</em> is set to indicate the error.</li><li><code>int sprintf(char *str, const char *format, ...);</code>: write its output to the character string pointed to by <em>str</em>. Upon successful return, it returns the number of characters printed (excluding the null byte used to end output to strings) and If an output error is encountered, a negative value is returned.</li><li><code>int getchar(void);</code>: equivalent to <u>fgetc</u>() except that it may be implemented as a macro which evaluates stream more than once. It returns the character read as an unsigned char cast to an int or <strong>EOF</strong> on end of file or error.</li><li><code>int putchar(int c);</code>: equivalent to <u>fputc</u>() except that it may be implemented as a macro which evaluates stream more than once. It returns the character written as an unsigned char cast to an int or <strong>EOF</strong> on error.</li><li>Common operation to clear the buffer<ul><li><code>{char c = 0; while((c = getchar()) != &#39;\n&#39; &amp;&amp; c != EOF);}</code> </li><li><code>int fflush(FILE *stream);</code>: it forces a write of all user-space buffered data for the given output or update stream via the stream’s underlying write function for output <em>streams</em>. And it discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application for input streams associated with seekable files (e.g., disk files, but not pipes or terminals). Upon successful completion 0 is returned. Otherwise, <strong>EOF</strong> is returned and <em>errno</em> is set to indicate the error.</li></ul></li></ul></li></ol><h3 id="Read-only-Variable-and-Constant"><a href="#Read-only-Variable-and-Constant" class="headerlink" title="Read-only Variable and Constant"></a>Read-only Variable and Constant</h3><ol><li>Read-only variable: a unchanged variable and its format is <code>const DataType VariableName = Value</code>.</li><li>Read-only variable is a variable and it needs storage space, while constant not.</li></ol><h2 id="Conditional-Structure"><a href="#Conditional-Structure" class="headerlink" title="Conditional Structure"></a>Conditional Structure</h2><h3 id="If-then-else-Statement"><a href="#If-then-else-Statement" class="headerlink" title="If - then - else Statement"></a>If - then - else Statement</h3><ul><li><p>Conditional statements, conditional expressions and conditional constructs are features of a programming language, which perform different computations or actions depending on whether a programmer-specified boolean <em>condition</em> evaluates to true or false. Apart from the case of branch predication, this is always achieved by selectively altering the control flow based on some condition.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( expression ) statement;</span><br><span class="line"><span class="keyword">if</span>( expression ) statement; <span class="keyword">else</span> statement;</span><br><span class="line"><span class="keyword">if</span>( expression1 ) statement1; <span class="keyword">else</span> <span class="keyword">if</span>( expression2 ) statement2; ... <span class="keyword">else</span> statementn;</span><br><span class="line"><span class="keyword">and</span> nesting of <span class="keyword">if</span> statement;</span><br></pre></td></tr></table></figure><ul><li><p>Specially, <strong>ctype.h</strong> header file contains some useful functions like <code>int isalpha(int c)</code>, <code>int isdigit(int c)</code>, <code>int ispunct(int c)</code>, <code>int islower(int c)</code>, <code>int isupper(int c)</code>, <code>int isspace(int c)</code>, <code>int toupper(int c)</code> and <code>int tolower(int c)</code>. The values returned are nonzero if the character <em>c</em> falls into the tested class, and zero if not.</p></li><li><p>C and C-like languages have a special ternary operator (<strong>?:</strong>) for conditional expressions with a function that may be described by a template like this.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression1?expression2:expression3</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Case-and-Switch-Statement"><a href="#Case-and-Switch-Statement" class="headerlink" title="Case and Switch Statement"></a>Case and Switch Statement</h3><ul><li><p>Switch statements (in some languages, case statements or multi-way branches) compare a given value with specified constants and take action according to the first constant to match. There is usually a provision for a default action (‘else’,’otherwise’) to be taken if no match succeeds. Switch statements can allow compiler optimizations, such as lookup tables. In dynamic languages, the cases may not be limited to constant expressions, and might extend to pattern matching, as in the shell script example on the right, where the ‘*)’ implements the default case as a regular expression matching any string.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>( expression --- the result must be integer )</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">case</span> constant expression1:  statement1; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> constant expression2: statement2; <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>: statementn; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// implement bank function</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cmd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> balance = <span class="number">0.0f</span>, deposit, withdraw;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"*** ACME checkbook-balancing program ***\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Commands: 0=clear, 1=deposit, 2=withdraw, 3=balance, 4=exit\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Enter command:"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cmd);</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            balance = <span class="number">0.0f</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Clear finished!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Enter amount of deposit: "</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;deposit);</span><br><span class="line">            balance += deposit;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Deposit finished!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Enter amount of withdraw: "</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;withdraw);</span><br><span class="line">            <span class="keyword">if</span> (withdraw &gt; balance) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"No enough momey!\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            balance -= withdraw;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Withdraw finished!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Current balance: $%.2f\n"</span>, balance);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Commands: 0=clear, 1=deposit, 2=withdraw, 3=balance, 4=exit\</span></span><br><span class="line"><span class="string">n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Cycle-Structure"><a href="#Cycle-Structure" class="headerlink" title="Cycle Structure"></a>Cycle Structure</h2><h3 id="While-Statement"><a href="#While-Statement" class="headerlink" title="While Statement"></a>While Statement</h3><ul><li><p>A while loop is a control flow statement that allows code to be executed repeatedly based on a given Boolean condition. The while loop can be thought of as a repeating if statement.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( expression )&#123; loop body&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Do-while-Statement"><a href="#Do-while-Statement" class="headerlink" title="Do-while Statement"></a>Do-while Statement</h3><ul><li><p>A do while loop is a control flow statement that executes a block of code at least once, and then repeatedly executes the block, or not, depending on a given boolean condition at the end of the block.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123; loop body &#125;<span class="keyword">while</span>( expression );</span><br></pre></td></tr></table></figure></li></ul><h3 id="For-Statement"><a href="#For-Statement" class="headerlink" title="For Statement"></a>For Statement</h3><ul><li><p>A for-loop (or simply for loop) is a control flow statement for specifying iteration, which allows code to be executed repeatedly. A for-loop has two parts: a header specifying the iteration, and a body which is executed once per iteration. The header often declares an explicit loop counter or loop variable, which allows the body to know which iteration is being executed. For-loops are typically used when the number of iterations is known before entering the loop. For-loops can be thought of as shorthands for while-loops which increment and test a loop variable.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( expression1; expression2; expression3 ) &#123; loop body &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print pyramid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> line, i, j, k;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Please input a number for the line:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;line);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; line; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = line - i; j &gt; <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">2</span> * i + <span class="number">1</span>; k++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Specially, <strong>;</strong> can not be omitted while expression1, expression2 and expression3 can be omitted.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print the multiplication table</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d*%d=%02d "</span>, i, j, i * j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Jump-Statement"><a href="#Jump-Statement" class="headerlink" title="Jump Statement"></a>Jump Statement</h3><ul><li><p>It performs a one-way transfer of control to another line of code; in contrast a function call normally returns control. The jumped-to locations are usually identified using labels, though some languages use line numbers. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Functions: </span><br><span class="line">transfer control of the program <span class="keyword">and</span> changes the execution process of the program</span><br><span class="line"></span><br><span class="line"><span class="function">go <span class="title">to</span><span class="params">(unconditional jump, use with caution)</span></span></span><br><span class="line"><span class="function"><span class="title">break</span><span class="params">(jump out of the loop)</span></span></span><br><span class="line"><span class="function"><span class="title">continue</span><span class="params">(skip the remaining statements in the body of the loop <span class="keyword">and</span> get into the next loop)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print primes between 100 and 200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Primes between 100 and 200 are:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>; i &lt; <span class="number">201</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= <span class="built_in">sqrt</span>(i + <span class="number">1</span>); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Operator-and-Expression"><a href="#Operator-and-Expression" class="headerlink" title="Operator and Expression"></a>Operator and Expression</h2><h3 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h3><ol><li><p>Classification of operators:</p><ul><li>Unary operator: <strong>&amp;</strong>, <strong>*</strong>, <strong>~</strong>, <strong>sizeof</strong>, <strong>()</strong></li><li>Binary operator: <strong>&gt;&gt;</strong>, <strong>&lt;&lt;</strong>, <strong>^</strong></li><li>Ternary operator: <strong>expression1?expression2:expression3</strong></li></ul></li><li><p>Arithmetic operator: <strong>+</strong>, <strong>-</strong>, <strong>*</strong>, <strong>/</strong>, <strong>%</strong></p></li><li><p>Relational operator: <strong>&lt;</strong>, <strong>&gt;</strong>, <strong>&lt;=</strong>, <strong>&gt;=</strong>, <strong>==</strong>, <strong>!=</strong></p></li><li><p>Logical operator: <strong>!</strong>, <strong>&amp;&amp;</strong>, <strong>||</strong>, Short circuit rule: for <strong>&amp;&amp;</strong>, if the left operand is 0, the result must be 0, right</p></li></ol><p>operands will not be calculated; For <strong>||</strong>, if the left operand is not 0, then the result must be 1, and the right operand will not be calculated.</p><ol><li><p>Comma operator: <strong>expression1, expression2</strong></p></li><li><p>Bit operator: <strong>&amp;</strong>, <strong>|</strong>, <strong>~</strong>, <strong>^</strong>, <strong>&lt;&lt;</strong>, <strong>&gt;&gt;</strong></p></li><li><p>Assigning operator: <strong>=</strong>, <strong>+=</strong>, <strong>-=</strong>, <strong>*=</strong>, <strong>\/=</strong>, <strong>%=</strong>, a l-value must be a storage cell and a r-value must be a certain value.</p></li></ol><h3 id="Type-Conversion"><a href="#Type-Conversion" class="headerlink" title="Type Conversion"></a>Type Conversion</h3><ol><li><p>The classification of type conversion</p><ul><li>Implicit conversion<ul><li>Usage scenarios<ul><li>The types of operand in an arithmetic or logical expression are different.</li><li>The type of the expression on the right side of the assignment operator does not match the type of the variable on the left.</li><li>An actual parameter type in a function call does not match its formal parameter type.</li><li>The type of the expression in the return statement does not match the type of the return value of the function.</li></ul></li><li>The improvement of data type<ul><li>char, short $ \rightarrow$ int $\rightarrow$ unsigned int $\rightarrow$ long int $\rightarrow$ unsigned long int</li><li>float $\rightarrow$ double $\rightarrow$ long double</li><li>integer $ \rightarrow$ float</li><li>signed $ \rightarrow$ unsigned</li></ul></li></ul></li><li>Explicit conversion: <code>(TypeSpecifier)(expression)</code>.</li></ul></li><li><p>True code, complemental code and ones-complement code</p><ul><li><p>For the positive number: True code = complemental code = ones-complement code.</p></li><li><p>For the negative number: True code: the same as positive number’s. complemental code: reverse true code and plus one. ones-complement code: the sign bit stays the same, the number bit is reversed.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swap the values of two integer variables</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d b:%d -before\n"</span>, a, b);</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a:%d b:%d -after\n"</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Basic-Knowledge-of-Function"><a href="#Basic-Knowledge-of-Function" class="headerlink" title="Basic Knowledge of Function"></a>Basic Knowledge of Function</h2><h3 id="Advantage-and-Classification-of-Function"><a href="#Advantage-and-Classification-of-Function" class="headerlink" title="Advantage and Classification of Function"></a>Advantage and Classification of Function</h3><ol><li>Advantages<ul><li>Make the program shorter and clearer.</li><li>Good for program maintenance.</li><li>Can improve the efficiency of code development.</li><li>Improve code reuse.</li></ul></li><li>Classifications<ul><li>Library function: provided by system, no need to be defined, must include header files.</li><li>User-defined function: need to be defined, and must be declared before in use.</li><li>Specially, the difference between inline function and macro with parameters is: When the function is called, control transfer will occur, and the code will be transferred to the function definition section and start running down. However, when the inline function is running to the function call, control transfer will not occur, but the function definition section will be directly copied down and run directly, which is defined as <code>inline DataType FunctionName();</code>.</li></ul></li></ol><h3 id="Definition-and-Calling-of-Function"><a href="#Definition-and-Calling-of-Function" class="headerlink" title="Definition and Calling of Function"></a>Definition and Calling of Function</h3><ol><li>Syntactic format for definition<ul><li>Function without parameters: <code>DataType FunctionName(){ statement };</code>.</li><li>Function with parameters: <code>DataType FunctionName( FormalParameterList ){ statement };</code>.</li><li>Specially, the type specifier indicates the return type of the function, and the content in <strong>{}</strong> is called the function body. If the function does not have return value, the return type is <strong>void</strong>, and it is not necessary to use the return statement; if it does, the return statement is required to return a value matching the return type.</li></ul></li><li>Syntactic format for calling: <code>FunctionName( ActualParameterList)</code>.</li><li>Actual parameter and formal parameter must be consistent in quantity, type and sequence. Specially, actual parameter must be determined value and the transfer is one-way( the formal $ \Rightarrow$ the actual ).</li><li>A nested call to a function: The calls to another function to occur within the definition of one function is allowed. No nested definitions of functions exist.</li></ol><h3 id="Concept-and-Declaration-of-Function-Prototype"><a href="#Concept-and-Declaration-of-Function-Prototype" class="headerlink" title="Concept and Declaration of Function Prototype"></a>Concept and Declaration of Function Prototype</h3><ol><li><p>Principle: first declare, then call and definitions cannot be repeated while declarations can.</p></li><li><p>Declaration of function prototype: the compilation system is notified of name and return type of the function, and number, type and sequence of the parameters, so that the statements containing the function calls can be checked against when compiled.</p></li><li><p>Usually a function can be declared in header files and defined in source files.</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test the compilation of the header file</span></span><br><span class="line"><span class="comment">// include/test.h</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// src/test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// src/main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please input a number:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line">    <span class="keyword">if</span> (!test(i)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"success!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"failure\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="One-dimensional-Array"><a href="#One-dimensional-Array" class="headerlink" title="One-dimensional Array"></a>One-dimensional Array</h3><ol><li><p>Concept: organize several variables orderly whose type is the same. In computer memory, all elements of an array are stored in adjacent storage locations in the order of subscript. Array name is the unique identifier of an array, and array elements are represented by array name and subscript.</p></li><li><p>Definition of linear array: <code>DataType ArrayName[ConstantExpression];</code>.</p></li><li><p>Initialization of linear array</p><ul><li><p><code>DataType ArrayName[ConstantExpression] = {Value1, Value2, ..., Valuen}</code>: When <em>ConstantExpression</em> is omitted in initialization, the system allocate the size of the array according to the numbers of values.</p></li><li><p><code>ArrayName[n] = An arithmetic expression for n</code>.</p></li><li><p><code>for(...){scanf(&quot;string of format control&quot;, &amp;ArrayName[n]);}</code>.</p></li><li><p>When the array is partly initialized, the unassigned element is initialized to 0 by default.</p></li><li><p>If you assign values to all elements, the length of the array may not be specified in the array definition.</p></li></ul></li><li><p>Usage to linear array: <code>ArrayName[Subscript]</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// enter a group of ages and count the age groups</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> persons[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please input ages: "</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;persons[i]);</span><br><span class="line">    <span class="keyword">int</span> ages[<span class="number">11</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = persons[i] / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= <span class="number">10</span>)</span><br><span class="line">            ages[<span class="number">10</span>]++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ages[k]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ages[%d]:%d\n"</span>, i, ages[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Two-dimensional-Array"><a href="#Two-dimensional-Array" class="headerlink" title="Two-dimensional Array"></a>Two-dimensional Array</h3><ol><li><p>Definition of two-dimensional array</p><ul><li><code>DataType ArrayName[ConstantExpression1][ConstantExpression2];</code>, thereamong the former represents row and the latter represents column. In <strong>C</strong> language, two-dimensional arrays are stored in rows with contiguous addresses.</li></ul></li><li><p>Initialization of two-dimensional array</p><ul><li>Row initializations can be omitted, but columns should never be omitted. Partial initializations are initialized to 0 by default.</li></ul></li><li><p>Usage of two-dimensional array: <code>ArrayName[RowSubscript][ColumnSubscript]</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print Yang Hui triangle</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++)</span><br><span class="line">            a[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please input row: "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;row);</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (k = row; k &gt; i; k--)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span> || i == j)</span><br><span class="line">                a[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                a[i][j] = a[i - <span class="number">1</span>][j] + a[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%2d"</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="High-Quality-Coding-Specification"><a href="#High-Quality-Coding-Specification" class="headerlink" title="High Quality Coding Specification"></a>High Quality Coding Specification</h2><h3 id="Macro-Coding-Specification"><a href="#Macro-Coding-Specification" class="headerlink" title="Macro Coding Specification"></a>Macro Coding Specification</h3><ol><li>Declaration of copyright and version<ul><li>Copyright information</li><li>File name, identifier and abstract</li><li>Current version, author or modifier and finish date</li><li>Version history information</li></ul></li><li>Structure of header file<ul><li>Declaration of copyright and version</li><li>Preprocess statements</li><li>Declaration of functions and structures</li></ul></li><li>Structure of source file<ul><li>Declaration of copyright and version</li><li>Including of header files</li><li>Data and code(Function annotation and statement annotation)</li></ul></li></ol><h3 id="Micro-Coding-Specification"><a href="#Micro-Coding-Specification" class="headerlink" title="Micro Coding Specification"></a>Micro Coding Specification</h3><ol><li>Usage of assert<ul><li><code>void assert(scalar expression);</code>: This macro can help programmers find bugs in their programs, or handle exceptional cases via a crash that will produce limited debugging output. If <em>expression</em> is false (i.e., compares equal to zero), it prints an error message to standard error and terminates the program by calling <u>abort</u>(). The error message includes the name of the file and function containing the its call, the source code line number of the call, and the text of the argument. And it is only used in debug version.</li></ul></li><li>Robustness of code must be considered when we apply for storage area in heap or use pointer.</li><li>Coding rule: Keep in mind that code is something to show people, not to show off.</li></ol><h2 id="Basic-Knowledge-of-Pointer"><a href="#Basic-Knowledge-of-Pointer" class="headerlink" title="Basic Knowledge of Pointer"></a>Basic Knowledge of Pointer</h2><h3 id="Pointer"><a href="#Pointer" class="headerlink" title="Pointer"></a>Pointer</h3><ol><li>Role of pointer<ul><li>Represent complex data structures effectively</li><li>Easy to use arrays and stings</li><li>Make function parameter passing more flexible</li><li>Able to deal with memory address</li></ul></li><li>Concept of pointer<ul><li>In computer science, a pointer is a programming language object that stores the memory address of another value located in computer memory. A pointer references a location in memory, and obtaining the value stored at that location is known as dereferencing the pointer. As an analogy, a page number in a book’s index could be considered a pointer to the corresponding page; dereferencing such a pointer would be done by flipping to the page with the given page number and reading the text found on that page. The actual format and content of a pointer variable is dependent on the underlying computer architecture. Using pointers significantly improves performance for repetitive operations like traversing iterable data structures, e.g. strings, lookup tables, control tables and tree structures. In particular, it is often much cheaper in time and space to copy and dereference pointers than it is to copy and access the data to which the pointers point.</li><li>Pointer is a variable, whose value is the address of another variable it points to. And a pointer variable is simply called a pointer. </li></ul></li><li>Definition of pointer<ul><li>Format: <code>DataType* PointerName;</code>, where <em>DataType</em> represents type of variable which the pointer points to. </li><li>Size: No matter what a pointer point to, its size is the same as one machine word-length.</li></ul></li><li>Initialization of point<ul><li>Format: <code>PointName = NULL;</code>, where <em>NULL</em> is equal to zero and it indicates the pointer points to nothing. <code>PointerName = &amp;VariableNAme;</code>.</li><li>Of course, we can define and initialize at the same time.</li></ul></li><li>Addition and subtraction operation: We can move the pointer by add and sub operation.</li><li>Name of array<ul><li>Name of array is a storage cell address of the first element address in the array.</li><li>Name of array is a constant and disable to be reassigned.</li><li>We can get another element in the array using offset.</li></ul></li><li>Traversal method of array<ul><li>Subscript method: <code>ArrayName[Subscript]</code></li><li>Pointer method: <code>*(ArrayName+Subsript)</code></li></ul></li></ol><h3 id="Segmentation-Fault"><a href="#Segmentation-Fault" class="headerlink" title="Segmentation Fault"></a>Segmentation Fault</h3><ol><li>Concept and cause of segmentation fault<ul><li>In computing, a segmentation fault (often shortened to segfault) or access violation is a fault, or failure condition, raised by hardware with memory protection, notifying an operating system (<strong>OS</strong>) the software has attempted to access a restricted area of memory (a memory access violation). On standard computers, this is a form of general protection fault. The <strong>OS</strong> kernel will, in response, usually perform some corrective action, generally passing the fault on to the offending process by sending the process a signal. Processes can in some cases install a custom signal handler, allowing them to recover on their own, but otherwise the <strong>OS</strong> default signal handler is used, generally causing abnormal termination of the process (a program crash), and sometimes a core dump. Segmentation faults are a common class of error in programs written in languages like C that provide low-level memory access. They arise primarily due to errors in use of pointers for virtual memory addressing, particularly illegal access. Another type of memory access error is a bus error, which also has various causes, but is today much rarer; these occur primarily due to incorrect physical memory addressing, or due to misaligned memory access – these are memory references that the hardware cannot address, rather than references that a process is not allowed to address.</li><li>Common case: overwrite nil pointer, access a nonexistent memory location, access a system-protected memory location and modify variables in the constant area.</li></ul></li><li>Common ways to avoid segmentation fault<ul><li>Better to initialize variables when defining them</li><li>Do not overstep the boundary of any array </li><li>Avoid to overwrite some protected or nonexistent memory cell</li></ul></li></ol><h3 id="Function-Parameter-Passing"><a href="#Function-Parameter-Passing" class="headerlink" title="Function Parameter Passing"></a>Function Parameter Passing</h3><ol><li>Call by value<ul><li>A parameter acts within the subroutine as a new local variable initialized to the value of the argument.</li><li>Call by value (also referred to as pass by value) is the most common evaluation strategy, used in languages as different as <strong>C</strong>. In call by value, the argument expression is evaluated, and the resulting value is bound to the corresponding variable in the function (frequently by copying the value into a new memory region). If the function or procedure is able to assign values to its parameters, only its local variable is assigned — that is, anything passed into a function call is unchanged in the caller’s scope when the function returns.</li></ul></li><li>Call by reference<ul><li>The argument variable supplied by the caller can be affected by actions within the called subroutine. </li><li>Call by reference (also referred to as pass by reference) is an evaluation strategy where a function receives an implicit reference to a variable used as argument, rather than a copy of its value. This typically means that the function can modify (i.e. assign to) the variable used as argument—something that will be seen by its caller. Call by reference can therefore be used to provide an additional channel of communication between the called function and the calling function. A call-by-reference language makes it more difficult for a programmer to track the effects of a function call, and may introduce subtle bugs. A simple “litmus test” for whether a language supports call-by-reference semantics is if it’s possible to write a traditional <code>swap(a,b)</code> function in the language</li></ul></li></ol><h3 id="Multiple-Indirection"><a href="#Multiple-Indirection" class="headerlink" title="Multiple Indirection"></a>Multiple Indirection</h3><ol><li>Concept of multiple indirection: In some languages, a pointer can reference another pointer, requiring multiple dereference operations to get to the original value. While each level of indirection may add a performance cost, it is sometimes necessary in order to provide correct behavior for complex data structures. For example, in <strong>C</strong> it is typical to define a linked list in terms of an element that contains a pointer to the next element of the list. And a basic example is in the argv argument to the main function in <strong>C</strong> (and <strong>C++</strong>), which is given in the prototype as <code>char **argv</code>—this is because the variable <code>argv</code> itself is a pointer to an array of strings (an array of arrays), so <code>*argv</code> is a pointer to the 0th string (by convention the name of the program), and <code>**argv</code> is the 0th character of the 0th string.</li><li>Definition and initialization of pointers to pointers: <code>DataType** Pointer2Name = &amp;Pointer1Name;</code></li></ol><h3 id="Constant-Pointer-and-Pointer-Constant"><a href="#Constant-Pointer-and-Pointer-Constant" class="headerlink" title="Constant Pointer and Pointer Constant"></a>Constant Pointer and Pointer Constant</h3><ol><li>Concept of constant pointer: In short, it is a pointer to a constant and the variable value it points to can not be changed.</li><li>Definition of constant pointer: <code>DataType const *PointerName</code></li><li>Usage of constant pointer: It is usually used to deny to modify the variable value the arguments points to when calling function. </li><li>Concept of pointer constant: In short, it is a pointer whose value can’t be changed while the variable value it points to can be changed.</li><li>Definition of pointer constant: <code>DataType *const PointerName</code></li></ol><h2 id="Supplement"><a href="#Supplement" class="headerlink" title="Supplement"></a>Supplement</h2><h3 id="Generating-Random-Number"><a href="#Generating-Random-Number" class="headerlink" title="Generating Random Number"></a>Generating Random Number</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> a = rand()%<span class="number">90</span>+<span class="number">10</span>; <span class="comment">//represent 10~99</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Do-Not-Display-Password"><a href="#Do-Not-Display-Password" class="headerlink" title="Do Not Display Password"></a>Do Not Display Password</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* password;</span><br><span class="line">    password = getpass(<span class="string">"Input password:"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The password is: %s\n"</span>, password);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C Language </tag>
            
            <tag> Basic Knowledge </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
